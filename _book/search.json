[
  {
    "objectID": "collaboration.html#section",
    "href": "collaboration.html#section",
    "title": "3  Collaboration Using Git",
    "section": "3.1 ",
    "text": "3.1"
  },
  {
    "objectID": "intro.html#what-does-git-do",
    "href": "intro.html#what-does-git-do",
    "title": "1  Introduction",
    "section": "1.1 What does Git do?",
    "text": "1.1 What does Git do?\nGit offers a way to track changes in your analysis without requiring the analyst to create different versions of the same file. To use git an analyst initializes their working directory (hopefully an R project). Files involved in the analysis (data, scripts, functions, model code) are added so that git knows to track changes associated with each file. When the analyst makes a commit, a snapshot of all tracked files at that specific point in time are recorded along with a message describing the commit and an automatically assigned a unique identifier. The analyst can also tag important commits. Because you can checkout prior commits this system allows for traditional file versioning with a structured system while ensuring the all commits are documented and the most important commits are easily identifiable.\nThe collection of all the commits, messages, tags and identifiers associated with a projects is called a repository. When a repository is created on your computer or private/company network it is local. An analyst can push a local repository to a remote repository (stored on the cloud). Alternatively, the analyst can pull a remote repository to their computer or private/company network to either create or update a local repository. Because multiple local repositories can push and pull to the same remote repository Git allows collaboration between analysts while maintaining the documentation and unique identifiers associated with each commit. Github is the most popular hosting service facilitating these collaborative features of Git."
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "2  The Basic Git Workflow",
    "section": "",
    "text": "Basic Git use includes how to create a repository, track changes in the files within your repository, view your repository history, and view line by line changes in modified files. The title for each section in this chapter will be a basic Git command with the text, code blocks, and figures in each section describing the use and result for each command.\n\n2.0.1 git init\nIf you have an empty folder that you would like make a git repository git init is the appropriate command. In the example below I have an empty folder named “git_practice” on S drive under S:/RTS/Reimer/Research_best_practices. The terminal session below shows 3 commands and the output received after each command: 1) verify the directory is not a git repository with git status, 2) make it a git repository with git init, 3) verify the directory is now a git repository with git status.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice\n$ git status\nfatal: not a git repository (or any of the parent directories): .git\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice\n$ git init\nInitialized empty Git repository in //dfg.alaska.local/DSF/Anchorage/RTS/Reimer/Research_Best_Practices/git_practice/.git/\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git status\nOn branch {main}\n\nNo commits yet\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n        .gitignore\n        git_practice.Rproj\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$\n\nThe git init command creates a git repository in your project directory. At this point, the repository is nearly empty but the git workflow has been enabled which will allow us to commit to the repository in the future. The rounded rectangle in Figure 2.1 indicates the contents of your working directory at this point in time. At the moment they are represented by an empty rectangle which indicates that the files in your working directory are in a Git work space. We will build this figure as we complete tasks within the Git work space.\n\n\n\n\n\nFigure 2.1: The Git workspace after you have initilized a repository.\n\n\n\n\n\n\n2.0.2 git add\nIn the last git status report shown above 2 files (.gitignore and git_practice.Rproj) were noted that could be added to the repository. Before we do that let’s create third file named fib_seq.R which contains a brief header and a single line of code fib_seq <- c(0, 1). The Fibonacci sequence is the sequence created when each value in the sequence is the sum of the 2 previous values in the sequence and the vector c(0, 1) initializes the sequence. We will add to this sequence to practice the use of Git. The terminal session below shows 5 commands: 1) view which files need to be added with git status, 2) add each file one at a time with git add, 3) verify all files have been added with git status. Notice that I made a typo while attempting to add the git_practice.Rproj file. I survived this catastrophe with a warning, which is typical of mistakes in the terminal.\n\n$ git status\nOn branch {main}\n\nNo commits yet\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n        .gitignore\n        fib_seq.R\n        git_practice.Rproj\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git add .gitignore\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git add fib_seq.R\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git_add git_practice.Rproj\nbash: git_add: command not found\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git add git_practice.Rproj\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git status\nOn branch {main}\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n        new file:   .gitignore\n        new file:   fib_seq.R\n        new file:   git_practice.Rproj\n\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$\n\nUse of git add stages files you would like to track in your git repository. The rectangle in Figure 2.2 is now filled which indicates that files within your working directory are staged and ready to be committed.\n\n\n\n\n\nFigure 2.2: The Git workspace after you have staged files in your working directory which you intend to add to your local repository.\n\n\n\n\nNotice Git tells you how to unstage a file if you added one inadvertently. On occasion there are files in your working directory which you do not want Git to track. Examples might be .pdf files for literature you referenced while conducting the analysis, word documents you produced for operational planning and reporting, or extremely large outputs. It’s fine to exclude these sort of files but before you do so consider… “Would a future researcher need access to this file to recreate my work?”. If they would you should track them in the repository.\nIt can be cumbersome to have a long list of files which Git recognizes as present in your working directory but you are not actively tracking. The solution is to open the file .gitignore and include the names of the files you do not want to track. You can use wildcards if you prefer not to track all files of a certain type and/or specify folders if you don’t want to track anything in certain sub-directories. For example, *.xlsx would ignore all .xlsx files in your working directory while posts/ would ignore all of the files in the folder posts within your working directory.\n\n\n2.0.3 git commit\nIn the git status response above 3 files were staged. Let’s commit those files in the terminal. In the terminal session below we verify all of the files we want to commit were staged using git status, recorded (committed) all of the staged files into the repository using git commit, verified the commit worked using git status and examined the repository log using git log.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git status\nOn branch {main}\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n        new file:   .gitignore\n        new file:   fib_seq.R\n        new file:   git_practice.Rproj\n\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git commit -m \"Initialize Fibonacci sequence\" -m \"Sequential additions to the Fibonacci sequence will provide a simple way to demonstrate several cycles of the git workflow including add/commit, push/pull, collaborate, fork, branch, merge, merge conflicts, exc. I even got my wife a GitHub account for this. Wish us luck!\"\n[{main} e17181f] Initialize Fibonacci sequence\n Date: Sun Jul 2 12:59:06 2023 -0800\n 3 files changed, 21 insertions(+)\n create mode 100644 .gitignore\n create mode 100644 fib_seq.R\n create mode 100644 git_practice.Rproj\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git status\nOn branch {main}\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git log\ncommit e17181fa781b2e30096e1c7d31443aac18d527e5 (HEAD -> {main})\nAuthor: Adam Reimer <adam.reimer@alaska.gov>\nDate:   Sun Jul 2 12:59:06 2023 -0800\n\n    Initialize Fibonacci sequence\n\n    Sequential additions to the Fibonacci sequence will provide a simple way to demonstrate several cycles of the git workflow including add/commit, push/pull, collaborate, fork, branch, merge, merge conflicts, exc. I even got my wife a GitHub account for this. Wish us luck!\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$\n\nThe git log command provides a summary of the commit. Two important parts are the commit ID and the commit message. The commit ID is a code which can be used to reference the commit in the future. Git assigned a long ID to each commit (e17181fa781b2e30096e1c7d31443aac18d527e5 for this commit) but its common to using only the first 7 characters of the commit ID (e17181f) to refer to the commit.\nCommit messages are required. Notice the commit message is broken into 2 parts. The first part is called the title or summary while the second part is called the description. A good practice is for the title to be brief (less that 50 characters) so that it displays well in most formats. There is no length limit for the description and this is the place to provide some explanation beyond what you can capture in the title. I’ve purposely been verbose with the commit above to demonstrate a long description.\n\n\n\n\n\nFigure 2.3: The Git workspace after you have committed your staged files to your local repository.\n\n\n\n\nThe git workflow described so far forms the basis on reproducible research using Git. We will calculate the next several values in the Fibonacci sequence to practice this workflow. The same sqence described above is repeated:\n\nA change is made to fib_seq.R (in this case a new line fib_seq[3] <- fib_seq[1] + fib_seq[2] is added) and saved to the working directory. Te working directory now represents a more recent snapshot of time that the local repository.\nThe changed file is staged.\nThe staged file is committed.\nRepeat steps 1 through 3.\n\nThe process looks like:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.0.3.1 When to Commit?\nSaves and a commits serve different purposes. As we all know, save can and should be used frequently… many times an hour and/or any time you are stepping away from your work. This use is agnostic to whether the analyst is or is not using a git workflow.\nIn contrast, commits are made for two reasons. First, a commit should be made whenever the analysis is at a point which you may want to revisit. Examples include; adding new data, adding a new feature to the analysis, or any time the code was run and the results were distributed. Any one of these tasks may have resulted in a new ‘version’ in the traditional workflow but they don’t have to be major updates. A second reason to commit is when the changes are substantive enough that the line-by-line change may be difficult to track if you did not commit until the new data/feature are complete. These commits snapshot significant steps in a new feature’s development or prior to experimenting with a new feature.\nThe most important thing to note regarding commits is that, unlike save, there is no temporal component. While saves are designed to minimize the risk of lost work and should be frequent in time, commits are designed to record importance stages of the analysis and should be frequent with respect to progress. A difficult feature may take days to code but represent a single commit, provided the actual changes to the code are modest. Efficiency in commit frequency will pay off when the repository is being revisited at a later date and each commit is a snapshot of the analysis that is important or informative to the reviewer.\n\n\n\n2.0.4 git log\nTo view our commit history in the terminal use git log. Note that the commit ID, author, date, commit title and commit description are all shown in the log.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git log\ncommit 11cf98ff67b8ec4f8cd7f2c1650a176d5875fdcf (HEAD -> {main})\nAuthor: Adam Reimer <adam.reimer@alaska.gov>\nDate:   Sun Jul 2 14:53:05 2023 -0800\n\n    Fourth entry in the Fibonacci sequence\n\n    Long and informative message goes here.\n\ncommit 3bb6c98bb0048bad7bda489bd8d40be24fb66acf\nAuthor: Adam Reimer <adam.reimer@alaska.gov>\nDate:   Sun Jul 2 14:31:04 2023 -0800\n\n    Third entry in fib_seq\n\n    This message is not necessary for such a simple commit, but descriptions are an important part of reproducible research I’m writing a long message to set a good example.  Have better content in yours.\n\ncommit e17181fa781b2e30096e1c7d31443aac18d527e5\nAuthor: Adam Reimer <adam.reimer@alaska.gov>\nDate:   Sun Jul 2 12:59:06 2023 -0800\n\n    Initialize Fibonacci sequence\n\n    Sequential additions to the Fibonacci sequence will provide a simple way to demonstrate several cycles of the git workflow including add/commit, push/pull, collaborate, fork, branch, merge, merge conflicts, exc. I even got my wife a GitHub account\nfor this. Wish us luck!\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$\n\n\n\n2.0.5 git diff\nTo see the difference between two commits use git diff. With no additional arguments git diff will show the changes in the working directory relative to the last commit. Our working directory has no changes as illustrated by git status. Instead we can add a short commit ID to the command to see changed between the current working directory and the commit 3bb6c9.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git status\nOn branch {main}\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git diff 3bb6c9\ndiff --git a/fib_seq.R b/fib_seq.R\nindex 9c118d5..4ce1d70 100644\n--- a/fib_seq.R\n+++ b/fib_seq.R\n@@ -2,4 +2,5 @@\n #Adam Reimer\n\n fib_seq <- c(0, 1)\n-fib_seq[3] <- fib_seq[1] + fib_seq[2]\n\\ No newline at end of file\n+fib_seq[3] <- fib_seq[1] + fib_seq[2]\n+fib_seq[4] <- fib_seq[2] + fib_seq[3]\n\\ No newline at end of file\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$\n\nGit GUI’s are superior to the terminal when looking at line-by line differences but for completeness we will discuss how to read the output. The section --- a/fib_seq.R to +++ b/fib_seq.R identifies the files that were modified where --- a/ and +++ b refer to the previous and the current versions of the file respectively. The line @@ -2,4 +2,5 @@ tells us that the output is showing the original file starting on the second line and displaying the the next 4 lines (three unmarked lines and the line with a negative symbol) while the new version of the file is also shown starting from the second line but displaying the next 5 lines (the three unmarked lines and the two lines with an addition symbol). This makes sense because a single line was added to the new version."
  },
  {
    "objectID": "advanced.html",
    "href": "advanced.html",
    "title": "4  Advanced Git Workflow",
    "section": "",
    "text": "Advanced Git workflows introduce some new concepts like reverting to a previous version and several skill which can help a researcher develop models/analysis including branching, merging and branch strategies. These concepts are likely overkill for simple analysis but can because very helpful for large projects.\n\n4.0.1 git checkout (HEAD~# or SHA key)\nTo recall a previous commit use git checkout and provide the SHA for the commit you wish to recall. You will receive and error message telling you GIT is in a detached HEAD state which simply means GIT is confused on which commit it should be considering the most recent; the commit you checked out or the last commit you made. Git tells you how to navigate this condition. If you only want to see the old code but not use it you can do that and simple checkout the most recent commit when you are done. I you want to revert to the old code the correct technique is to create a new branch and merge it back with the old branch accepting the code form each branch.\nWhile making this book I realized I may have inadvertently deleted a file I need. In the terminal sequence below shows how I repaired that problem. First I used git checkout to revert to my work space during the last commit (HEAD~1 is shorthand for 1 commit prior). I cut and pasted the files I needed, they magically appeared in my working directory because I had add/committed them earlier, and attempted git switch to reverted back to the most recent commit. This didn’t work so I tried git checkout 57ba5a3d which allowed me to explicitly state the commit I wanted to go to using the SHA key 57ba5a3d, which also failed to work. At that point I shut down all files/windows that referenced anything to do with this project (this is a common problem with Git… something to do with Windows only allowing one application to access each file at a time. After that I was able to checkout the most current commit and reattach the head.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book (master)\n$ git checkout HEAD~1\nUpdating files: 100% (30/30), done.\nNote: switching to 'Head~1'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by switching back to a branch.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -c with the switch command. Example:\n\n  git switch -c <new-branch-name>\n\nOr undo this operation with:\n\n  git switch -\n\nTurn off this advice by setting config variable advice.detachedHead to false\n\nHEAD is now at 27bd7c8 Initial commit\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book ((27bd7c8...))\n$ git switch -\nerror: cannot stat '_book/collaboration_files': Permission denied\nerror: cannot stat '_book/collaboration_files': Permission denied\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book ((27bd7c8...))\n$ git checkout 57ba5a3d\nerror: cannot stat '_book/collaboration_files': Permission denied\nerror: cannot stat '_book/collaboration_files': Permission denied\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book ((27bd7c8...))\n$ git status\nHEAD detached at 27bd7c8\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book ((27bd7c8...))\n$ git checkout 57ba5a3d\nUpdating files: 100% (30/30), done.\nPrevious HEAD position was 27bd7c8 Initial commit\nHEAD is now at 57ba5a3 draft collab chapter/general updates\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book ((57ba5a3...))\n$ git status\nHEAD detached at 57ba5a3\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book ((57ba5a3...))\n$ git checkout master\nSwitched to branch 'master'\n\n\n\n\n\n\n4.0.2 git checkout -b new_branch_name old_branch-name\nI like to think of branches as a line of model development. A best practice is to create a new branch any time you are experimenting with a new feature that you are not sure you want/need or that you think may take several commits to complete."
  },
  {
    "objectID": "RStudio.html#section",
    "href": "RStudio.html#section",
    "title": "Appendix A — The RStudio Graphical User Interface",
    "section": "A.1 ",
    "text": "A.1"
  },
  {
    "objectID": "collaboration.html",
    "href": "collaboration.html",
    "title": "3  Collaboration Using Git",
    "section": "",
    "text": "Git has some amazing reproducible research capabilities that can become really powerful in large complicated analyses. That said, utilizing Git comes with an overhead that may not be justified for small projects unless you consider collaboration with future analysts including yourself. To demonstrate Git’s collaborative potential I created a remote repository on GitHub called git_practice.\n\n3.0.1 Interacting with your Remote Repository\n\n3.0.1.1 git push\nTo link your local repository to a remote repository use git remote. In the terminal session below I added a remote repository named “origin” and provided a url where the repository is located. The second command created a new branch in the remote named main. The third command “pushed” my local repository to my remote repository. Files associated with this repository are now stored in a location where they can be accessed by others for viewing, download, or collaborative work.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git remote add origin https://github.com/adamreimer/git_practice.git\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git branch -M main\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git push -u origin main\nEnumerating objects: 11, done.\nCounting objects: 100% (11/11), done.\nDelta compression using up to 16 threads\nCompressing objects: 100% (10/10), done.\nWriting objects: 100% (11/11), 1.53 KiB | 8.00 KiB/s, done.\nTotal 11 (delta 2), reused 0 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (2/2), done.\nTo https://github.com/adamreimer/git_practice.git\n * [new branch]      main -> main\nbranch 'main' set up to track 'origin/main'.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$\n\nAfter pushing to github your repository now looks like Figure 3.1.\n\n\n\n\n\nFigure 3.1: The Git workspace after your local repository has been pushed to a remote repository.\n\n\n\n\nNow that we have a remote repository updated we have to worry about keeping them both synced. To illustrate this workflow I’ll change the fib_seq.r file by adding the fifth value to the Fibonacci sequence (fib_seq[5] <- fib_seq[3] + fib_seq[4]) as a new line. After this change the git work space will contain an unstaged change which is not reflected in either repository.\n\n\n\n\n\nFigure 3.2: The Git workspace after the working directory has been changed leaving the local and remote repositories out-of-date.\n\n\n\n\nIn the terminal session below I stage the file fib_seq.R and commit the file. Notice the first time we submitted a git status command we were told the local and remote repositories were synced but that there were unstaged changes. After the modified file was added and committed the second call to git status tells us our remote repository is one commit behind our local repository. The git work space at this moment is illustrated by Figure 3.3.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   fib_seq.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git add fib_seq.R\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git commit -m \"Fifth entry in the Fibonacci sequence\" -m \"A long and descriptive description\"\n[main 5139049] Fifth entry in the Fibonacci sequence\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git status\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$\n\n\n\n\n\n\nFigure 3.3: The Git workspace after a local change has been staged & committed leaving the remote repositories one commit behind.\n\n\n\n\nIn the terminal session below I use git push to update the remote repository. Notice git status verifies the repositories are now synced. The git work space at this moment is illustrated by Figure 3.4.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git push\nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 16 threads\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 414 bytes | 8.00 KiB/s, done.\nTotal 3 (delta 1), reused 0 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (1/1), completed with 1 local object.\nTo https://github.com/adamreimer/git_practice.git\n   0c92881..5139049  main -> main\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$\n\n\n\n\n\n\nFigure 3.4: The Git workspace after a local change has been staged, committed, and pushed.\n\n\n\n\n\n\n3.0.1.2 git clone\nImagine a situation where you would like to work on your analysis from a home computer1. If your analysis is stored as a git repository it is easy to obtain a copy from a different computer. In the terminal sequence below we navigate to my home computer’s C drive, clone the remote repository to the C drive, navigate to the new local repository, and check the repository status. Notice that I made a typo on the git status command the first time and nothing terrible happened.\n\namreimer@DFGSXQDSF223076 MINGW64 ~/Documents\n$ cd C:/\n\namreimer@DFGSXQDSF223076 MINGW64 /c\n$ git clone https://github.com/adamreimer/git_practice.git\nCloning into 'git_practice'...\nremote: Enumerating objects: 14, done.\nremote: Counting objects: 100% (14/14), done.\nremote: Compressing objects: 100% (10/10), done.\nremote: Total 14 (delta 3), reused 14 (delta 3), pack-reused 0\nReceiving objects: 100% (14/14), done.\nResolving deltas: 100% (3/3), done.\n\namreimer@DFGSXQDSF223076 MINGW64 /c\n$ cd C:/git_practice\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git_status\nbash: git_status: command not found\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$\n\nAfter git clone the my remote repository to my home machine I have two local repositories associated with the same remote(see Figure 3.5).\n\n\n\n\n\nFigure 3.5: The Git workspace when you have two local repositories associated with the same remote.\n\n\n\n\nIf I change the file fib_seq.R in the working directory of my home computer by adding a new line (fib_seq[6] <- fib_seq[4] + fib_seq[5]), stage and commit those changes in the local repository on my home computer, and push my home computer’s local repository to the remote repository the local repository on my S drive to be behind one commit. The terminal session below demonstrated these commands (all of which we have seen before) and the current state of the Git work space is shown in Figure 3.6.\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   fib_seq.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git add fib_seq.R\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git commit -m \"Sixth number in the Fibonacci seqence\" -m \"This commit is slightly different as it was made from a different computer in my house. It still represents a single author working on their own repository but demonstrated the flexibility accorded by storing your analysis on the cloud. Working on this analysis from a new machine was seamless provided the new machine had the appropriate software.\"\n[main 9db5478] Sixth number in the Fibonacci seqence\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git status\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git push\nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 16 threads\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 586 bytes | 586.00 KiB/s, done.\nTotal 3 (delta 1), reused 0 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (1/1), completed with 1 local object.\nTo https://github.com/adamreimer/git_practice.git\n   5139049..9db5478  main -> main\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$\n\n\n\n\n\n\nFigure 3.6: The Git workspace when you have one local repository has pushed a new commit to the remote repository.\n\n\n\n\n\n\n3.0.1.3 git pull\nAs Figure 3.6 demonstrate the local repository on my S drive is now one commit behind the remote (and the local repository on my C drive). In the terminal session below we try git status but are told the local and remote repositories are synced, which we know to be false. Git has lost track of the remote since the repository on the S drive was blind to the last commit. Instead we use git update to update the remote connection, after which git status works as before. Finally, git pull brings the local repository on the S drive into sync with the remote. At this point the local and remote repositories have the structure of Figure 3.5 but will include an additional commit (9db5478) not shown in Figure 3.5.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git remote update\nremote: Enumerating objects: 5, done.\nremote: Counting objects: 100% (5/5), done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0\nUnpacking objects: 100% (3/3), 566 bytes | 0 bytes/s, done.\nFrom https://github.com/adamreimer/git_practice\n   5139049..9db5478  main       -> origin/main\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git status\nOn branch main\nYour branch is behind 'origin/main' by 1 commit, and can be fast-forwarded.\n  (use \"git pull\" to update your local branch)\n\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git pull\nUpdating 5139049..9db5478\nFast-forward\n fib_seq.R | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$\n\n\n\n\n3.0.2 Interacting with a Peer’s Remote Repository\nHow you interact with a peers remote repository depends on your goals. We will discuss three typical use cases below.\n\n3.0.2.1 git clone - To Copy/Modify Code\nImagine a situation where a peer has written some code which you would like to modify for a similar project2. Use git clone as described above. You will be able to create a copy of their repository and work on your local machine as usual, but you will not be able to push changes back to the remote.\n\n\n3.0.2.2 git clone, git push, git pull - To Collaborate (closely)\nIf you and a peer are working closely on a analysis it may be appropriate for the owner to add their peer as a collaborator to the project. This is a point-and-click task from your github repository page, Settings>Collaborators>Add people>(keypunch the username). The collaborator can push and pull changes to the remote as if they were the owner. This arraignment is only appropriate for peers who you trust to commit changes of which you both approve. In practice, this likely means there will be personal communication to coordinate each person’s efforts. To demonstrate this process I added my wife (Carly) as a collaborator to the git_practice repository. Carly then cloned the repository, modified the fib_seq.R file by adding a new line (fib_seq[7] <- fib_seq[5] + fib_seq[6]), staged the file, committed the changes, and pushed her local repository back to the git_practice remote. Afterwards I pulled those changes back to the local repository on my S drive. The terminal sessions and figures associated with these actions would closely mirror those shown for git clone, git push, and git pull above although the local repositories have different owners in this case. To demonstrate commits were made by both collaborators I ran a specially formatted call3 to git log which shows that the latest commit to this repository did come form a new author.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git log --pretty=format:\"%h%x09%an%x09%ad%x09%s\"\nf732cdb Carly Reimer    Sun Jul 2 22:01:17 2023 -0800   Seventh Fibonacci number\n9db5478 Adam Reimer     Sun Jul 2 20:39:19 2023 -0800   Sixth number in the Fibonacci seqence\n5139049 Adam Reimer     Sun Jul 2 16:15:52 2023 -0800   Fifth entry in the Fibonacci sequence\n0c92881 Adam Reimer     Sun Jul 2 14:53:05 2023 -0800   Fourth entry in the Fibonacci sequence\n3bb6c98 Adam Reimer     Sun Jul 2 14:31:04 2023 -0800   Third entry in fib_seq\ne17181f Adam Reimer     Sun Jul 2 12:59:06 2023 -0800   Initialize Fibonacci sequence\n\n\n\n3.0.2.3 fork - To Collaborate (formally)\nFork is a GitHub operation which creates a copy of another users remote repository under your GitHub ID. After the fork is created you can clone it to a local repository as described above. Your local repository can be configured to sync with the original (upstream) repository so that your local repository can track changes the original author made after fork. If you make significant changes to the repository that the original author may be interested in you can submit a pull request which notifies the original author about the changes you have made and gives them the opportunity to include your code in the repository. Github has great documentation of this process.\nAs an example I revoked my wife’s collaborator status on the git_practice repository associated with my GitHub account. Carly then forked the git_practice repository in my account. Afterwards, the forked version of the git_practice repository in her account looked something like this:\n\n\n\nThe forked git_practice repository in Carly Reimer’s GitHub account\n\n\nUsing the same commands describe above Carly cloned the forked repository, made changes, added the changed file, committed the changes, and pushed the result back to her forked repository on Github. Pull requests are so named because Carly is asking me to pull her forked repository back into my original repository. The initiate a pull request the owner of the forked repository (Carly) navigates to the original repository and presses the Pull request button. The pull request looked like this when veiwed from my account:\n\n\n\nThe pull request summary screen.\n\n\nNavigating the the Files changed button allows the repository owner to review line by line changes associated with the pull request. In this case, I deemed the suggestions reasonable and accepted them without comment but there are capabilities to comments and modify the changes before they are accepted.\n\n\n\nThe pull request review/approval screen\n\n\nAfter the request is approved the original owner can merge the pull request from within GitHub.\n\n\n\nMerging a pull request\n\n\nAfter merging the pull request; Carly’s local repository, the forked repository, and the original remote repository are synced while Adam’s local repository is behind. This situation could be fixed with git pull.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git pull\nremote: Enumerating objects: 12, done.\nremote: Counting objects: 100% (12/12), done.\nremote: Compressing objects: 100% (7/7), done.\nremote: Total 10 (delta 3), reused 9 (delta 3), pack-reused 0\nUnpacking objects: 100% (10/10), 2.60 KiB | 1024 bytes/s, done.\nFrom https://github.com/adamreimer/git_practice\n   f732cdb..22dcfea  main       -> origin/main\nUpdating f732cdb..22dcfea\nFast-forward\n fib_seq.R | 8 ++++++--\n 1 file changed, 6 insertions(+), 2 deletions(-)\n\n\n\n\n\n\n\n\nI hope your analysis is on the network and you could use vpn to solve this problem.↩︎\nCommon courtesy requires you to ask permission and credit the person who originally wrote the code.↩︎\nThanks Jesper Rønn-Jensen! Note: %h specifies the short commit ID, %x09 specifies a tab, %an specifies the author, %ad specifies the commit date, and %s specifies the commit title.↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ADF&G Division of Sport Fisheries Introduction to Git",
    "section": "",
    "text": "Preface\nThe author is aware that each analyst has a unique level of expertise and each analysis has unique requirements. As the analyst it is up to you to use professional judgment to decide which techniques are useful for the analysis you are conducting. That said, we offer the following general advice."
  },
  {
    "objectID": "index.html#division-of-sport-fish-github-transition",
    "href": "index.html#division-of-sport-fish-github-transition",
    "title": "ADF&G Division of Sport Fisheries Introduction to Git",
    "section": "Division of Sport Fish Github Transition",
    "text": "Division of Sport Fish Github Transition\nBiometricans with ADF&G Sport fish will be required to store their analysis on GitHub starting in 2024. This means that all operations plans and reports published in 2024 and later will be required to reference a GitHub site and a specific commit where the published analysis is stored. This decision was reached by a consensus of Biometrican IIIs and will streamline final biometric reviews and transitioning projects between biometrics staff. This document was produced to help provide guidance for satisfying this requirement."
  },
  {
    "objectID": "intro.html#how-do-i-interact-with-git",
    "href": "intro.html#how-do-i-interact-with-git",
    "title": "1  Introduction",
    "section": "1.2 How do I interact with Git?",
    "text": "1.2 How do I interact with Git?\nOne problem with widespread adoption of Git at ADF&G is that there is no accepted standard for how to interact with Git. The options are a GUI (graphical user interface) or a command line interface (terminal). Herein, we will focus on how to use Git while interacting through the terminal. We make this choice for 3 reasons. First, because the terminal is a command line interface it is easy to demonstrate the exact steps that were taken to achieve each outcome. This presentation is more concrete than a parade of screenshots. A second issue is that there are a lot of GUIs out there. I will include an appendix which shows how to do the most common Git functions in RStudio. While not a particuarly good Git GUI the RStudio interface is sufficient for most tasks and readily available for most readers of this book. If you have a GUI you highly recommend we welcome your input. Please fork the repository associated with this book, add an appendix with instructions for your prefered GUI and submit a pull request… instructions on how to do so are included in the chapter on collaboration. A final reason to use command line in the context of this book is that the terminal commands are commonly described in Stack Overflow if you Google how to accomplish a task in Git. Rest assured, I don’t use the terminal to interact with Git the majority of the time1 and I don’t recommend you do either. But I do think you will end up there eventually, that the terminal has pedagogical advantages and that if you can use the terminal the GUI’s are easier to understand.\nIn order to use the terminal effectively it helps to make one change to the Rstudio defaults by executing the following point and click commands: Tools>Terminal>Terminal Options…>(change initial directory to ‘project directory’). This change will ensure your terminal opens in the correct directory and save some unnecessary terminal commands."
  },
  {
    "objectID": "intermediate.html",
    "href": "intermediate.html",
    "title": "4  Intermediate Git Workflow",
    "section": "",
    "text": "The intermediate Git workflow introduces a new concept: branches. Efficient use of branches and a well thought out branching strategy will aid the analyst in Git use and is also a powerful tool for model development.\n\n4.0.1 Branches and Branch strategy\nIn Git a branch is a pointer to a specific commit or set of commits which allow you to separate model development tasks into smaller subunits. I learned branching from this guy and in what follows I simplify his workflow into something that works well for complicated fisheries analyses. Let’s start by creating a new branch named develop using the command git checkout. The argument -b tells Git to checkout a new branch while the arguments develop and main tell Git the name of the new branch and that the new branch should branch from the main branch.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git checkout -b develop main\nSwitched to a new branch 'develop'\n\nThe core concept in the Git Flow branching strategy is to always have two active branches; main and develop. The main branch is stable in that you make limited commits to it and those commits are associated with internal or external reporting including FDS reports, BOF memos, or conference presentations. Because the main branch will largely be static interested collaborators can quickly identify the analysis at the time periods where the analysis was reported.\nThe develop branch is the working branch and will have frequent commits relative to analysis progress. The develop branch merges into main at reporting periods and is the branched from whenever a new feature is being developed.\nFeature branches are created frequently as new features are envisioned and developed. A best practice is to create a new feature branch, with a descriptive name, every time your create a new feature. When the feature is completed it is merged back into develop, left as a record without a merge, or deleted. In my work, feature branches are mostly merged back into develop, and this occurs whenever I create a feature which improves the analysis. Feature branches are left unmerged when I want to retain a record of having tried something (and the result) but do not think it improves the overall analysis. Feature branches are deleted without merging when something just did not work out and is also not worth retaining as a record. Notice that liberal use of feature branches keep the main and develop branches clean and can isolate those two primary branches of a lot of the sloppiness that is a byproduct of actively engaging in the scientific process.\nLet’s practice Git Flow. In the terminal session which follows we create a new branch called cleanup with git checkout, modify the file fib_seq.R by deleting several lines, show the changes using git diff, add those changes, and commit those changes.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git checkout -b cleanup develop\nSwitched to a new branch 'cleanup'\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (cleanup)\n$ git status\nOn branch cleanup\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   fib_seq.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (cleanup)\n$ git diff\ndiff --git a/fib_seq.R b/fib_seq.R\nindex 984a0a5..97be5b3 100644\n--- a/fib_seq.R\n+++ b/fib_seq.R\n@@ -2,12 +2,7 @@\n #Adam Reimer & Carly Reimer\n\n fib_seq <- c(0, 1)\n-fib_seq[3] <- fib_seq[1] + fib_seq[2]\n-fib_seq[4] <- fib_seq[2] + fib_seq[3]\n-fib_seq[5] <- fib_seq[3] + fib_seq[4]\n-fib_seq[6] <- fib_seq[4] + fib_seq[5]\n-fib_seq[7] <- fib_seq[5] + fib_seq[6]\n-for (i in 8:51) fib_seq[i] <- sum(fib_seq[(i-1):(i-2)])\n+for (i in 3:51) fib_seq[i] <- sum(fib_seq[(i-1):(i-2)])\n\n plot(1:50, fib_seq[2:51]/fib_seq[1:50], type = \"l\")\n-{golden_ration <- fib_seq[51]/fib_seq[50]}\n+{golden_ratio <- fib_seq[51]/fib_seq[50]}\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (cleanup)\n$ git add fib_seq.R\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (cleanup)\n$ git commit -m \"remove maanual Fibonacci calculations\" -m \"manual calculations become redundent now that we are using recurstion to get the series.\"\n[cleanup 8b28369] remove maanual Fibonacci calculations\n 1 file changed, 2 insertions(+), 7 deletions(-)\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$\n\n\n\n4.0.2 git merge\nThe changes above are reasonable and the new feature tried on the cleanup branch is useful. In the terminal session below we use git checkout to switch back to the develop branch, git merge to merge the cleanup branch with the develop branch, and git branch to delete the cleanup branch now that it’s change has been incorporated into develop.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (cleanup)\n$ git checkout develop\nSwitched to branch 'develop'\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git merge --no-ff cleanup\nMerge made by the 'ort' strategy.\n fib_seq.R | 9 ++-------\n 1 file changed, 2 insertions(+), 7 deletions(-)\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git branch -d cleanup\nDeleted branch cleanup (was 8b28369).\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$\n\n\n4.0.2.1 Merge conflicts\nMerge conflicts can occur any time we are merging two branches. In what follows we will intentionally create a merge conflict and fix it. In the terminal session below I create a new branch named label_plot, and while working on that branch modify the file fib_seq.R by adding informative figure labels and then stage/commit those changes.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git checkout -b label_plot develop\nSwitched to a new branch 'label_plot'\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (label_plot)\n$ git status\nOn branch label_plot\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   fib_seq.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (label_plot)\n$ git add fib_seq.R\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (label_plot)\n$ git commit -m \"Added axis labels to golden ratio plot.\" -m \"Not a lot to say but hammering home the idea that more informative messages are better. In this case I added labels to demonstrate a merge conflict. Will add different labels to the same file/figure on branch develop to create the conflict.\"\n[label_plot a4c0f61] Added axis labels to golden ratio plot.\n 1 file changed, 4 insertions(+), 1 deletion(-)\n \namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (label_plot)\n$\n\nA merge into the develop branch at this stage would be both appropriate and successful. The new feature was added to the feature branch label_plot was a improvement, and the develop branch is unchanged. Instead we will intentionally change the develop branch (violating the spirit of Git Flow) to demonstrate a merge conflict. In the terminal session that follows we: checkout the develop branch and while working on that branch modified the file fib_seq.R by adding less informative figure labels, and stage/commit those changes. We then use git show to look at the copy of fib_seq.R from both the develop and label_plot branches. Notice that the axis labels from the label_plot branch are more informative. Because the values given to the xlab and ylab arguments were modified in both branches we can expect a merge conflict and, as expected, a merge conflict results from attempting to merge these branches.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (label_plot)\n$ git checkout develop\nSwitched to branch 'develop'\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git status\nOn branch develop\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   fib_seq.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git add fib_seq.R\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git commit -m \"Added labels to the golden ratio figure\" -m \"These labels are intentionally less informative that the labels added on the feature branch to demonstrate that feature branches are where you do the work which you then merge into develop.\"\n[develop d0d260e] Added labels to the golden ratio figure\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git show develop:fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq <- c(0, 1)\nfor (i in 3:51) fib_seq[i] <- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Number\",\n     ylab = \"Ratio\")\n{golden_ratio <- fib_seq[51]/fib_seq[50]}\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git show label_plot:fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq <- c(0, 1)\nfor (i in 3:51) fib_seq[i] <- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Fibonacci Number in Denominator\",\n     ylab = \"Ratio Between Succesive Fibonacci Numbers\")\n{golden_ratio <- fib_seq[51]/fib_seq[50]}\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git merge --no-ff label_plot\nAuto-merging fib_seq.R\nCONFLICT (content): Merge conflict in fib_seq.R\nAutomatic merge failed; fix conflicts and then commit the result.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$\n\nWhen there is a merge conflict Git modifies the file being merged to help the user decide how to proceed. Git adds <<<<<<< HEAD above the merge conflict. The text ====== separates the merge conflict into code derived from each branch. Code between <<<<<< HEAD and ====== indicates code which was present in the branch being merged into (develop in this case) while code between ====== and >>>>>> label_plot indicates code which was present in the branch being merged (label_plot in this case). I’ve shown what that fib_seq.R file in my working directory looks like using the terminal command cat, but that is only for demonstrative purposes. Normally, I would just open the file in RStudio, and it would look exactly the same. To proceed the user has to decide which code to keep, save the modified file, and stage/commit the changes. For this example I deleted everything between <<<<<< HEAD and ====== inclusive as well as the line >>>>>> label_plot. These deletions made the file fib_seq.R we merged match the version in the label_plot branch.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop|MERGING)\n$ cat fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq <- c(0, 1)\nfor (i in 3:51) fib_seq[i] <- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n<<<<<< HEAD\n     type = \"l\",\n     xlab = \"Number\",\n     ylab = \"Ratio\")\n======\n     type = \"l\",\n     xlab = \"Fibonacci Number in Denominator\",\n     ylab = \"Ratio Between Succesive Fibonacci Numbers\")\n>>>>>> label_plot\n{golden_ratio <- fib_seq[51]/fib_seq[50]}\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop|MERGING)\n$ git status\nOn branch develop\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n  (use \"git add <file>...\" to mark resolution)\n        both modified:   fib_seq.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop|MERGING)\n$ git add fib_seq.R\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop|MERGING)\n$ git commit -m \"fixed merge conflict by accepting changes from label_plot branch\" -m \"Mmaybe the only good example of a situation were a description is not nessesary.\"\n[develop ad2149a] fixed merge conflict by accepting changes from label_plot branch\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git status\nOn branch develop\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$\n\n\n\n\n4.0.3 Interacting with your Git history\n\n4.0.3.1 Restoring a previous version of a file\nYou can also use git checkout to recall a single file from a previous commit. In the terminal sequence below I use cat and git show to show that the file in my work directory and the file in the most recent commit to the develop branch are the same file. Notice a call to git status reports the same thing without showing the files explicitly.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ cat fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq <- c(0, 1)\nfor (i in 3:51) fib_seq[i] <- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Fibonacci Number in Denominator\",\n     ylab = \"Ratio Between Succesive Fibonacci Numbers\")\n{golden_ratio <- fib_seq[51]/fib_seq[50]}\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git show develop:fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq <- c(0, 1)\nfor (i in 3:51) fib_seq[i] <- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Fibonacci Number in Denominator\",\n     ylab = \"Ratio Between Succesive Fibonacci Numbers\")\n{golden_ratio <- fib_seq[51]/fib_seq[50]}\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git status\nOn branch develop\nnothing to commit, working tree clean\n\nTo retrieve a specific file from a prior commit you have to provide git checkout with identifying information for the commit and the file name. You can specify the appropriate commit with a absolute or relative reference. For an absolute reference provide the SHA #. For a relative reference the shorthand is HEAD~# where # is the number of commits prior to the latest commit. In the terminal sequence below I used checkout to retrieve a copy of fib_seq.R from 1 commit earlier (recall this commit had the less informative x and y axis labels). Notice the earlier version of fib_seq.R was present in my working directory (as shown in the output for cat) but was not included in the latest commit to my repository (as shown in the output to git show). If I wanted the earlier version of fib_seq.R to be associated with the most recent commit to my repository I would need to commit the file. In this case I did not want to change my repository so I used git checkout to go back the the most recent version. I often use this sequence to recall all or part of a code from a prior commit.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git checkout HEAD~1 fib_seq.R\nUpdated 1 path from abb8fba\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ cat fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq <- c(0, 1)\nfor (i in 3:51) fib_seq[i] <- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Number\",\n     ylab = \"Ratio\")\n{golden_ratio <- fib_seq[51]/fib_seq[50]}\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git show develop:fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq <- c(0, 1)\nfor (i in 3:51) fib_seq[i] <- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Fibonacci Number in Denominator\",\n     ylab = \"Ratio Between Succesive Fibonacci Numbers\")\n{golden_ratio <- fib_seq[51]/fib_seq[50]}\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git status\nOn branch develop\nChanges to be committed:\n  (use \"git restore --staged <file>...\" to unstage)\n        modified:   fib_seq.R\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git checkout HEAD fib_seq.R\nUpdated 1 path from bd65128\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ cat fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq <- c(0, 1)\nfor (i in 3:51) fib_seq[i] <- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Fibonacci Number in Denominator\",\n     ylab = \"Ratio Between Succesive Fibonacci Numbers\")\n{golden_ratio <- fib_seq[51]/fib_seq[50]}\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$\n\n\n\n4.0.3.2 Retrieving a prior commit\nYet another use of git checkout is to recall a previous commit in it’s entirety. Since our repository only has one file I created, staged and committed a second file named test.R to demonstrate this functionality. In the terminal sequence below I show the contents of test.R and some now familiar content where I check the status of my repository and stage/commit the new file.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ cat test.R\n#Blank file to see if we can use git checkout to retrieve an entire commit.\n#Proof would be seeing this file and the correct version of fib_seq.R\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git status\nOn branch develop\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n        test.R\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git add test.R\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git commit -m \"Test.R file added. Used to test that git checkout recalls an entire commit\" -m \"added a second file so to verify both files come when I jump around commits.\"\n[develop 4ef90af] Test.R file added. Used to test that git checkout recalls an entire commit\n 1 file changed, 2 insertions(+)\n create mode 100644 test.R\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$\n\nTo retrieve a prior commit you should create a new branch to house the past commit until you decide what to do with it. While not strictly necessary creating a new branch is stable and protects your develop branch. In the terminal session below I use git checkout to create a new branch called old_state and fill it with the snapshot of the develop branch from 2 commits earlier. I am expecting old state to be missing test.R and have the less descriptive axis locations in the version of fib_seq.R. Two calls to cat confirm that my working directory does not contain test.R and has the older version of fib_seq.R\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git checkout -b old_state HEAD~2\nSwitched to a new branch 'old_state'\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (old_state)\n$ cat fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq <- c(0, 1)\nfor (i in 3:51) fib_seq[i] <- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Number\",\n     ylab = \"Ratio\")\n{golden_ratio <- fib_seq[51]/fib_seq[50]}\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (old_state)\n$ cat test.R\ncat: test.R: No such file or directory\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (old_state)\n$ git status\nOn branch old_state\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$\n\nThe next action depends on if you want the keep working on the prior commit. If you do you can modify files and stage/commit the result as appropriate prior to merging old_state back into develop. Since you purposely started the old_state feature branch from a prior version of develop the odds of a merge conflict are high. It does mean it’s a terrible idea but you should be doing this with intention. In the terminal session below I decided the prior commit was not an improvement on my original commit so I moved back to the develop branch and deleted the old_state branch. Two calls to cat prove that the original files were returned.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (old_state)\n$ git checkout develop\nSwitched to branch 'develop'\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ cat fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq <- c(0, 1)\nfor (i in 3:51) fib_seq[i] <- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Fibonacci Number in Denominator\",\n     ylab = \"Ratio Between Succesive Fibonacci Numbers\")\n{golden_ratio <- fib_seq[51]/fib_seq[50]}\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ cat test.R\n#Blank file to see if we can use git checkout to retrieve an entire commit.\n#Proof would be seeing this file and the correct version of fib_seq.R\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git branch -d old_state\nDeleted branch old_state (was d0d260e).\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$\n\n\n\n4.0.3.3 Deleating/Reversing a commit\nThere are two ways to reverse a commit. The version you should choose depends on if you have pushed the commit to a remote repository.\n\n4.0.3.3.1 Deleting a local commit\nWhen the bad commit is local you can us git reset to delete the commit. The commit will disappear from your history. To demonstrate this command I modified the fib_seq.R by adding an inconsequential comment at the bottom of the file and used the cat command to show the file. After adding and committing the file a call to git log shows that the commit was recorded.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ cat fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq <- c(0, 1)\nfor (i in 3:51) fib_seq[i] <- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Fibonacci Number in Denominator\",\n     ylab = \"Ratio Between Succesive Fibonacci Numbers\")\n{golden_ratio <- fib_seq[51]/fib_seq[50]}\n\n#Useless comment to demonstrate how to delete a commit\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git add fib_seq.R\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git commit -m \"bad commit, plan to delete\" -m \"This commit has one change, a useless comment added to the fib_seq.R file. Plan to reset the HEAD to delete the commit\"\n[develop ae2fe59] bad commit, plan to delete\n 1 file changed, 2 insertions(+)\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git log --oneline\nae2fe59 (HEAD -> develop) bad commit, plan to delete\n4ef90af Test.R file added. Used to test that git checkout recalls an entire commit\nad2149a fixed merge conflict by accepting changes from label_plot branch\nd0d260e Added labels to the golden ratio figure\na4c0f61 Added axis labels to golden ratio plot.\neb216a6 Merge branch 'cleanup' into develop\n8b28369 remove maanual Fibonacci calculations\n22dcfea (origin/main, main) Merge pull request #2 from carlyreimer/main\nf811c50 Update fib_seq.R\nedbaafa Update fib_seq.R\nac48c12 Finally added a for loop and golden ratio estimate\nf732cdb Seventh Fibonacci number\n9db5478 Sixth number in the Fibonacci seqence\n5139049 Fifth entry in the Fibonacci sequence\n0c92881 Fourth entry in the Fibonacci sequence\n3bb6c98 Third entry in fib_seq\ne17181f Initialize Fibonacci sequence\n    \namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$    \n\nIn the terminal session below I use git reset to reset my local repository to 1 commit prior to the most recent commit. Notice that the comment I added to the most recent commit is no longer a part of the fib_seq.R file and that the commit ae2fe59d44eec001b949c3677f94f78e0c30a216 has been removed for the repository. The important thing to note is git reset changes the repository history. If you are working locally this is OK but if you have already pushed the bad commit to a remote then deleting a part of your history will cause problems for collaborators who pulled the original history.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git reset HEAD~1 --hard\nHEAD is now at 4ef90af Test.R file added. Used to test that git checkout recalls an entire commit\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ cat fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq <- c(0, 1)\nfor (i in 3:51) fib_seq[i] <- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Fibonacci Number in Denominator\",\n     ylab = \"Ratio Between Succesive Fibonacci Numbers\")\n{golden_ratio <- fib_seq[51]/fib_seq[50]}\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git log --oneline\n4ef90af (HEAD -> develop) Test.R file added. Used to test that git checkout recalls an entire commit\nad2149a fixed merge conflict by accepting changes from label_plot branch\nd0d260e Added labels to the golden ratio figure\na4c0f61 Added axis labels to golden ratio plot.\neb216a6 Merge branch 'cleanup' into develop\n8b28369 remove maanual Fibonacci calculations\n22dcfea (origin/main, main) Merge pull request #2 from carlyreimer/main\nf811c50 Update fib_seq.R\nedbaafa Update fib_seq.R\nac48c12 Finally added a for loop and golden ratio estimate\nf732cdb Seventh Fibonacci number\n9db5478 Sixth number in the Fibonacci seqence\n5139049 Fifth entry in the Fibonacci sequence\n0c92881 Fourth entry in the Fibonacci sequence\n3bb6c98 Third entry in fib_seq\ne17181f Initialize Fibonacci sequence\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git status\nOn branch develop\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$\n\n\n\n4.0.3.3.2 Reversing a local/remote commit\nBecause revising your history in a public repository is bad collaboration Git has devised a solution. The git revert command can also be used to undo a mistaken commit but it does so in a very deliberate way… by creating a new commit that exactly undoes the prior commit. This method provides a stable Git history to your collaborators. In the git session below I modified the fib_seq.R again (with an inconsequential comment) and added/committed the change. git log shows the new commit.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git status\nOn branch develop\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   fib_seq.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git add fib_seq.R\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git commit -m \"bad commit, plan to revert\" -m \"This commit has one change, a useless comment added to the fib_seq.R file. Plan to revert the commit\"\"\n> \"\n[develop a0c849e] bad commit, plan to revert\n 1 file changed, 2 insertions(+)\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git log --oneline\na0c849e (HEAD -> develop) bad commit, plan to revert\n4ef90af Test.R file added. Used to test that git checkout recalls an entire commit\nad2149a fixed merge conflict by accepting changes from label_plot branch\nd0d260e Added labels to the golden ratio figure\na4c0f61 Added axis labels to golden ratio plot.\neb216a6 Merge branch 'cleanup' into develop\n8b28369 remove maanual Fibonacci calculations\n22dcfea (origin/main, main) Merge pull request #2 from carlyreimer/main\nf811c50 Update fib_seq.R\nedbaafa Update fib_seq.R\nac48c12 Finally added a for loop and golden ratio estimate\nf732cdb Seventh Fibonacci number\n9db5478 Sixth number in the Fibonacci seqence\n5139049 Fifth entry in the Fibonacci sequence\n0c92881 Fourth entry in the Fibonacci sequence\n3bb6c98 Third entry in fib_seq\ne17181f Initialize Fibonacci sequence\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$\n\nUsing git revert I specify the short SHA id from the prior commit. The call to git log shows that a new commit was added with a message specifying the commit reverted the commit titled “bad commit, plan to revert”.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git revert a0c849e\n[develop 6466f85] Revert commit titled: \"bad commit, plan to revert\"\n 1 file changed, 2 deletions(-)\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git log --oneline\n6466f85 (HEAD -> develop) Revert commit titled: \"bad commit, plan to revert\"\na0c849e bad commit, plan to revert\n4ef90af Test.R file added. Used to test that git checkout recalls an entire commit\nad2149a fixed merge conflict by accepting changes from label_plot branch\nd0d260e Added labels to the golden ratio figure\na4c0f61 Added axis labels to golden ratio plot.\neb216a6 Merge branch 'cleanup' into develop\n8b28369 remove maanual Fibonacci calculations\n22dcfea (origin/main, main) Merge pull request #2 from carlyreimer/main\nf811c50 Update fib_seq.R\nedbaafa Update fib_seq.R\nac48c12 Finally added a for loop and golden ratio estimate\nf732cdb Seventh Fibonacci number\n9db5478 Sixth number in the Fibonacci seqence\n5139049 Fifth entry in the Fibonacci sequence\n0c92881 Fourth entry in the Fibonacci sequence\n3bb6c98 Third entry in fib_seq\ne17181f Initialize Fibonacci sequence\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git status\nOn branch develop\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$"
  },
  {
    "objectID": "intro.html#conventions-used-in-this-book",
    "href": "intro.html#conventions-used-in-this-book",
    "title": "1  Introduction",
    "section": "1.3 Conventions used in this book",
    "text": "1.3 Conventions used in this book\nThroughout this document you will find code blocks which show the command line prompt, the command given, and the result received for each action demonstrated. Code blocks are identifiable by a grey bar along the left hand margin. In the terminal, each command line prompt ($) is proceeded by the username, shell type, and directory location. In the terminal session below we can see that the username was amreimer@DFGSXQDSF206801, the shell type was MING64 and the directory location was S:/RTS/Reimer/Research_Best_Practices/git_practice.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice\n$\n\nWhen point and click sequences are referenced in this text button names will be shown in italic, button names in series will be separated by and the greater than symbol (>) and any actions required will be described using (italics enclosed in parenthesis). For an example see the last paragraph of the preceding section.\nWhen git commands are referenced in the text they will be displayed as an inline code block. R objects and Git branches are also referenced as inline code blocks."
  },
  {
    "objectID": "RStudio.html",
    "href": "RStudio.html",
    "title": "Appendix A — The RStudio Graphical User Interface",
    "section": "",
    "text": "Congratulations! If you are reading this you have done your homework and earned the right to confidently use a graphical user interface to simplify the most common Git tasks. Using a GUI can save a lot of keystrokes for most commands. The most accessible GUI is found in RStudio itself. A Git tab will show up in the Environment/History/Connections/Tutorial window (generally the upper left hand quadrant) provided your directory is a Git repository.\n\n\n\nThe RStudio windows with the Git pane shown in the top right quadrant.\n\n\n\nA.0.1 git init\nIf you are starting a brand new analysis creating a git repository at the same time you create your R studio project is easy: New Project>New Directory>New Project>(provide name, location and check ‘create git repository’). This sequence runs git init in the background while the RStudio project is created\n\n\nA.0.2 Commands accessible through the Git tab\n\ngit add - add/Stage files by clicking the radio button next to each file in the RStudio Git pane.\ngit diff- the Diff button will lead to another screen where the GUI allows users to commit, diff and log the repository.\ngit commit - the Commit button will lead to another screen where the GUI allows users to commit, diff and log the repository.\ngit pull - the Pull button allows the user to pull commits from the remote repository to the local repository.\ngit push - the Push button allows the user to push commits from the local repository to the remote repository.\ngit log - the History button will lead to another screen where the GUI allows users to commit, diff and log the repository.\ngit revert - the More button will allow the user to revert a commit. IT also allows the user to add files to the .gitignore file by clicking the radio button next to the files you wish to ignore.\ngit checkout -b and git remote - the flowchart shaped button will allow you to create a new branch and add a remote to the repository.\ngit checkout <new_branch> - the drop down list next to the word “main” will allow you to switch between branches.\nNote the RStudio GUI is frequently slow to react to changes. The circular arrow refreshes the GUI. Often it will look like nothing is happening when you are clicking the radio buttons to add/stage files but clicking the refresh button will reveal the buttons were checked.\n\n\n\n\nThe RStudio Git tab\n\n\n\n\nA.0.3 Commands accessible through the Diff/Commit/History window\n\ngit diff - the Changes tab will show line by line changes associated with the files in the working directory relative to the most recent commit. Old lines are shown in red while new line are shown in green.\ngit commit - the Changes tab includes a commit message window and a Commit button allowing the user to commit all of the staged changes. The commit title goes on the first line of the message window, followed by a blank line. The third line and onward contain the commit description.\ngit log - the History tab will show the list of prior commits and the line by line changes associated with each file included in each commit.\n\n\n\n\nThe Diff/Commit/History window\n\n\n\n\nA.0.4 Commands not accessible using the RStudio GUI\nTo my knowledge you cannot use RStudio to:\n\ngit merge two branches.\n\ncomment - This feels like a big deal if you intend to use Git optimally.\n\ngit checkout to recall a single file from a previous commit.\n\ncomment - I’ve done this allot. It is sometimes possible to cut/paste a peice for revised code from the GUI history but it is usually formatted poorly which can be a pain if the section you need is large.\n\ngit checkout to recall a prior commit to your working directory.\n\ncomment - Not needed often. I’ve generally been more interested in a single file.\n\ngit reset to delete a local commit.\n\ncomment - I have done this rarely.\n\nImpress your friends by making your computer do things without using your mouse.\n\ncomment - My friends think I’m a dork and this only exacerbates things in that regard."
  }
]