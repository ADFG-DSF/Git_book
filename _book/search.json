[
  {
    "objectID": "collaboration.html#section",
    "href": "collaboration.html#section",
    "title": "3  Collaboration Using Git",
    "section": "3.1 ",
    "text": "3.1"
  },
  {
    "objectID": "intro.html#what-does-git-do",
    "href": "intro.html#what-does-git-do",
    "title": "1  Introduction",
    "section": "1.1 What does Git do?",
    "text": "1.1 What does Git do?\nGit offers a way to track changes is your analysis without requiring the analyst to create different versions of the same file. To use git an analyst initializes their working directory (hopefully an R project). Files involved in the analysis (data, scripts, functions, model code) are added to the ask git to track changes associated with each file. When the analyst makes a commit, a snapshot of all tracked files at a specific point in time are recorded along with a message describing the commit and a automatically assigned a unique identifier. The analysis can also tag important commits. Because you can checkout prior commits this system duplicates file versioning with a structured system while ensuring the all commits are documented and the most important commits are easily identifiable.\nThe collection of all the commits, messages, tags and identifiers associated with a projects is called a repository. When a repository is created on your computer or private/company network it is local. An analyst can push a local repository to a remote repository (stored on the cloud). Alternatively, the analyst can pull a remote repository to their computer or private/company network to either create or update a local repository. Because multiple local repositories can push and pull to the same remote git allows collaboration between analysts which maintains the documentation and unique identifier features. Github is the most popular hosting service facilitating these collaborative features of git."
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "2  The Basic Git Workflow",
    "section": "",
    "text": "Herein we will focus on learning Git using the Terminal. The terminal is the easiest to demonstrate in a text document and everything you need to do can be done in the terminal. I’ll demonstrate the most important commands in the text that follows. In order to use the terminal effectively it helps to make one change to the Rstudio defaults by executing the following point and click commands: Tools>Terminal>Terminal Options…>(change initial directory to ‘project directory’). This change will ensure your terminal opens in the correct directory and save some unnecessary terminal prompts.\nThat said, many users find it easier to interact with Git through a graphical user interface (GUI). The most accesible is found in RStudio itself. A Git tab will show up in the Environment/History/Connections/Tutorial window provided your directory is a Git repository. Using a GUI that can save a lot of keystrokes for simple commands and often displays revisions more clearly that they are displayed in the shell. The drawbacks are that some commands can only be completed in the terminal, each GUI different, and point and click commands are difficult to demonstrate in a text document. For this reason, we will focus on the terminal but show how to complete each command in the Rstudio GUI in the appendix. In practice, I tend to work with a combination of the terminal and the Rstudio GUI.\n\n2.0.1 git init\nIf you have an existing Rstudio project1 that needs to become a git repository git init is the appropriate command. In the example below I have a Rstudio project in a folder named “git_practice_A” on S drive under S:/RTS/Reimer/Research_best_practices. In the terminal, each command line prompt ($) is proceeded by the username, shell type, and directory location.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A\n$\n\nThe terminal sequence below shows 3 commands and the output recieved after each command: 1) verify the directory is not a git repository with git status, 2) make is a git repository with git init, 3) verify the directory is now a git repository with git status.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A\n$ git status\nfatal: not a git repository (or any of the parent directories): .git\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A\n$ git init\nInitialized empty Git repository in //dfg.alaska.local/DSF/Anchorage/RTS/Reimer/Resear\nch_Best_Practices/git_practice_A/.git/\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A\n(master)\n$ git status\nOn branch master\n\nNo commits yet\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n        .gitignore\n        git_practice_A.Rproj\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A\n(master)\n$\n\nThe git init command creates a git repository in your project directory. At this point, the repository is empty, but the git workflow has been enabled which will allow us to commit to the repository in the future. The arrow in Figure 2.1 indicates your analysis has moved into the git workspace and now sits in your working directory.\n\n\n\n\n\nFigure 2.1: The Git workspace after you have initilized an repository.\n\n\n\n\n\n\n2.0.2 git add\nIn the git status response above 2 files (.gitignore and git_practice_A.Rproj) were noted that could be added to the repository. Before we do that let’s create third file named fib_seq.R which contains nothing but the vector c(0, 1). The Fibonacci seqence is the sequence created when each value in the sequence is the sum of the 2 previous values in the sequence. We will add to this sequence to practice the use of git. The terminal sequence below shows 5 commands: 1) view which files need to be added with git status, 2) add each file one at a time with git add, 3) verify all files have been added with git status.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$ git status\nOn branch master\n\nNo commits yet\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n        .gitignore\n        fib_seq.R\n        git_practice_A.Rproj\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$ git add .gitignore\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$ git add fib_seq.R\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$ git add git_practice_A.Rproj\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$ git status\nOn branch master\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n        new file:   .gitignore\n        new file:   fib_seq.R\n        new file:   git_practice_A.Rproj\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$\n\nUse of git add stages files you would like to track for inclusion in your git repository. The arrow in Figure 2.2 indicates that files within your working directory were moved into the staging area.\n\n\n\n\n\nFigure 2.2: The Git workspace after you have staged files in your working directory which you intend to add to your local repository.\n\n\n\n\nOn occasion there are files in your working directory which you do not want Git to track. If you don’t add them they will not get tracked but it can also be cumbersome to have a long list of files which Git recognizes as present in your working directory but you are not actively tracking. The solution is to open the file .gitignore and add the files you don’t want to track line by line. You can use wildcards if you prefer not to track all files of a certain type and or specify folders if you don’t want to track anything inn certain sub-directories. For example, *.xlsx would ignore all .xlsx files in your working directory while posts/ would ignore all of the files in the folders posts within your working directory.\n\n\n2.0.3 git commit\nIn the git status response above 3 files were staged. Let’s commit those files in the terminal.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$ git status\nOn branch master\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n        new file:   .gitignore\n        new file:   fib_seq.R\n        new file:   git_practice_A.Rproj\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$ git commit -m \"Inital commit\" -m \"Started a Fibonaccci sequence to practice git\"\n[master (root-commit) 45bb4b2] Inital commit\n 3 files changed, 20 insertions(+)\n create mode 100644 .gitignore\n create mode 100644 fib_seq.R\n create mode 100644 git_practice_A.Rproj\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$ git status\nOn branch master\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$ git log\ncommit 45bb4b2a18f07c33bfbe89b7b762008426059409 (HEAD -> master)\nAuthor: Adam Reimer <adam.reimer@alaska.gov>\nDate:   Tue Jun 27 13:29:16 2023 -0800\n\n    Inital commit\n\n    Started a Fibonaccci sequence to practice git\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$\n\nIn the terminal sequence above all three staged files were added to the repository (committed) with a single line of code. Notice the commit message is broken into 2 parts. The first part is called the title or summary while the second part is called the description. A good practice is for the title to be brief (less that 50 characters) so that it displays well in most formats. There is no length limit for the description and this is the place to provide some explanation beyond what you can capture in the title.\n\n\n\n\n\nFigure 2.3: The Git workspace after you have committed your staged files to your local repository.\n\n\n\n\nThe git workflow described so far forms the basis on reproducible research using Git. In our example we will add single numbers to the Fibonacci sequence to practice this workflow. After a change is made and saved to the working directory your Git workspace will look something like:\n\n\n\n\n\nThose changes are then added:\n\n\n\n\n\nAnd then committed:\n\n\n\n\n\nAnd this cycle is repeated untill the first 5 numbers of the Fibonacci sequence are calculated:\n\n\n\n\n\n\n2.0.3.1 When to Commit?\nSaves and a commits serve different purposes. As we all know, save can and should be used frequently… many times an hour and/or any time you are stepping away from your work. This use is agnostic to whether the analysis is using a traditional or git workflow.\nIn contrast, commits are made for two reasons. First, a commit should be made whenever the analysis is at a point which you may want to revisit. Examples include; adding new data, adding a new component to the analysis, or any time the code was run and the results were distributed. Any one of these tasks may have resulted in a new ‘version’ in the traditional workflow but they don’t have to be major updates. The commit may also snapshot significant steps in a new features development or prior to experimenting with a new feature. These commits allow you to revert back to the previous code in the event the new feature is not an improvement. An example commit message in these situations could look something like:\n\nage-at-maturity trend\n\nallow for temporal trend in age at maturity using logistic regression w a year covariate.\n\nA second reason to commit is when the changes are substantive enough that the line-by-line change may be difficult to track if you did not commit until the new data/feature are complete. An example would be a run reconstruction project where you have multiple data sources and associated data entry formatting codes associated with each. A mid-process commit message in that scenario could be something like:\n\npartial add 2024 data\n\ninriver harvest and netting added and changed to rectangular format. Need to add marine harvest and all index of abundacne data\n\nThe most important thing to note regarding commit messages is that, unlike save, there is no temporal component. While saves are designed to minimize the risk of lost work and should be frequent in time, commits are designed to record importance stages of the analysis and commits should be frequent with respect to progress. A difficult feature may take days to code but represent a single commit, provided the actual changes to the code are modest. Efficiency in commit frequency pay off when the repository is being revisited at a later date.\n\n\n\n2.0.4 git log\nThe view our commit history in the terminal use git log. For this example I have not been including descriptions with my commit messages becaseu the changes were simple enought to describe in the title. That said, not that for the first commit both the commit title and commit descritpption are shown in the log. The advantage to using git log is that both the title and detail message for each commit are shown.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$ git log\ncommit 247d383ead7899fcd3eff2eb5c902ffc314c1d8a (HEAD -> master)\nAuthor: Adam Reimer <adam.reimer@alaska.gov>\nDate:   Tue Jun 27 13:51:09 2023 -0800\n\n    fifth number added to Fibonnacci sequence\n\ncommit 5c23113e233d4957f72439e0cf5729104817287f\nAuthor: Adam Reimer <adam.reimer@alaska.gov>\nDate:   Tue Jun 27 13:50:08 2023 -0800\n\n    forth number added to Fibonnacci sequence\n\ncommit 2730310ae971ed325c517fa5e180ebcef7065f5e\nAuthor: Adam Reimer <adam.reimer@alaska.gov>\nDate:   Tue Jun 27 13:48:58 2023 -0800\n\n    third number added to Fibonnacci sequence\n\ncommit 45bb4b2a18f07c33bfbe89b7b762008426059409\nAuthor: Adam Reimer <adam.reimer@alaska.gov>\nDate:   Tue Jun 27 13:29:16 2023 -0800\n\n    Inital commit\n\n    Started a Fibonaccci sequence to practice git\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$\n\n\n\n2.0.5 git diff\nIll add one more line to fib_seq.R to illustrate how Git shows us line by line changes in a file. In the terminal sequence below there are unstaged changes and git diff was used to see what change was made. The last command reverts back to the previous version of the file.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   fib_seq.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$ git diff\ndiff --git a/fib_seq.R b/fib_seq.R\nindex 0ba340f..7b29418 100644\n--- a/fib_seq.R\n+++ b/fib_seq.R\n@@ -3,4 +3,5 @@\n fib_seq <- c(0, 1)\n fib_seq[3] <- fib_seq[1] + fib_seq[2]\n fib_seq[4] <- fib_seq[2] + fib_seq[3]\n-fib_seq[5] <- fib_seq[3] + fib_seq[4]\n\\ No newline at end of file\n+fib_seq[5] <- fib_seq[3] + fib_seq[4]\n+fib_seq[6] <- fib_seq[4] + fib_seq[5]\n\\ No newline at end of file\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$ git restore fib_seq.R\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$\n\nGit GUI’s are superior to the terminal when looking at line-by line differences but for completeness we will discuss how to read the output. The section --- a/fib_seq.R` to +++ b/fib_seq.R identifies the files that were modified where --- a/ and +++ b refer to the previous and the current versions of the file respectively. The line @@ -3,4 +3,5 @@ tells us that the output is showing the original file starting on the third line and displaying the the next 4 lines (the three unmarked lines and the line with a negative symbol) while the new version of the file is also shown starting from the third line but displaying the next 5 lines (the three unmarked lines and the two line with a addition symbol). This makes sense because a single line was added to the new version.\n\n\n\n\n\n\nside note: if you have an existing project directory that needs to become an Rstudio project the appropriate point and click sequence is New Project>Existing Directory>(provide location)↩︎"
  },
  {
    "objectID": "advanced.html",
    "href": "advanced.html",
    "title": "4  Advanced Git Workflow",
    "section": "",
    "text": "Advanced Git workflows introduce some new concepts like reverting to a previous version, branching, merging, merge conflicts and model development. These concepts are likely overkill for simple analysis but can because very helpful for large projects.\n\n4.0.1 git checkout\nTo recall a previous commit use git checkout and provide the SHA for the commit you wish to recall. You will receive and error message telling your GIT is in a detached HEAD state which simply means GIT is confused on which commit it should be considering the most recent; the commit you just checked out or the last commit you made. Git tells you how to navigate this condition. If you only want to see the old code but not use it you can do that and simple checkout the most recent commit when you are done. I rarely do that… if all I wanted to do was see the changes I would use the GUI. I you want to revert to the old code the correct technique is to crate a new branch and merge it back with the old branch accepting the code form each branch ."
  },
  {
    "objectID": "RStudio.html#section",
    "href": "RStudio.html#section",
    "title": "Appendix A — The RStudio Graphical User Interface",
    "section": "A.1 ",
    "text": "A.1"
  },
  {
    "objectID": "collaboration.html",
    "href": "collaboration.html",
    "title": "3  Collaboration Using Git",
    "section": "",
    "text": "Git has some amazing reproducible research capabilities that can become really powerful in large complicated analyses. That said, utilizing Git comes with an overhead that may not be justified for small projects unless you consider collaboration with future analysts including yourself. To utilize Git’s collaborative potential create a remote repository on github. I created one called git_practice.\n\n3.0.1 Interacting with your Remote Repository\n\n3.0.1.1 git push\nTo link your local repository to a remote repository use git remote. In the terminal output below I added a remote repository named “origin” and provided a url where the repository is located. The second command “pushed” my local repository to my remote repository. Files associated with this repository are now stored in a location where they can be accessed by others for collaborative work.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$ git remote add origin https://github.com/adamreimer/git_practice.git\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$ git push -u origin master\nEnumerating objects: 14, done.\nCounting objects: 100% (14/14), done.\nDelta compression using up to 16 threads\nCompressing objects: 100% (13/13), done.\nWriting objects: 100% (14/14), 1.55 KiB | 52.00 KiB/s, done.\nTotal 14 (delta 3), reused 0 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (3/3), done.\nTo https://github.com/adamreimer/git_practice.git\n * [new branch]      master -> master\nbranch 'master' set up to track 'origin/master'.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A (master)\n$\n\nAfter pushing to github your repository now looks like Figure 3.1.\n\n\n\n\n\nFigure 3.1: The Git workspace after your local repository has been pushed to a remote repository.\n\n\n\n\n\n\n3.0.1.2 git clone\nImagine a situation where you would like to work on your analysis from a home computer1. If your analysis is stored as a git repository it is easy to obtian a copy from a differetn machine. In the terminal sequence below we: navigate to a new (empty) folder where I would like to copy the git repository and clone the remote repository to my local machine.\n\namreimer@DFGSXQDSF206801 MINGW64 ~/OneDrive - State of Alaska/Documents\n$ cd S:/RTS/Reimer/Research_Best_Practices\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices\n$ ls\n Biometric_Best_Practices/  'Data super group'/   Git_book/   git_practice_A/   git_practice_B/   git_practice_C/   SSDL_test/\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices\n$ cd S:/RTS/Reimer/Research_Best_Practices/git_practice_C\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_C\n$ ls\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_C\n$ git clone https://github.com/adamreimer/git_practice.git .\nCloning into '.'...\nremote: Enumerating objects: 14, done.\nremote: Counting objects: 100% (14/14), done.\nremote: Compressing objects: 100% (10/10), done.\nremote: Total 14 (delta 3), reused 14 (delta 3), pack-reused 0\nReceiving objects: 100% (14/14), done.\nResolving deltas: 100% (3/3), done.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_C (master)\n$\n\nAfter git clone the my git work space on my home machine looks the same as Figure 3.1. If I make changes, add the changes files and commit those changes the local repository on your home machine will be one commit ahead of both your remote repository and the local repository on your work machine Figure 3.2. git status would verify the discrepancy between your local repository (at home) and your remote repositories and git push -u origin master would sync the two repositories.\n\n\n\n\n\nFigure 3.2: The Git workspace on your home computer after git clone and one commit.\n\n\n\n\n\n\n3.0.1.3 git pull\nNow your local repository at work will be one commit behind your local repsotiry at home and your remote repository. In the terminal sequence below we use git status to verify the remote repository is one commit ahead of the remote and git pull to fetch the new commit and merge it to your local working directory.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A\n(master)\n$ git status\nOn branch master\nYour branch is behind 'origin/master' by 1 commit, and can be fast-forwarded.\n  (use \"git pull\" to update your local branch)\n\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A\n(master)\n$ git pull\nUpdating 247d383..b3b6ae3\nFast-forward\n fib_seq.R | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice_A\n(master)\n\n\n\n\n3.0.2 Interacting with a Peer’s Remote Repository\nHow you interact with a peers remote repository depends on your goals. We will discuss three typical use cases below.\n\n3.0.2.1 git clone - To Copy/Modify Code\nImagine a situation where a peer has some code written which you would like to modify for a similar project2. Use git clone as described above. You will be able to create a copy of their repository and work on your local machine as usual, but you will not be able to push changes back to the remote.\n\n\n3.0.2.2 git clone, git push, git pull - To Collaborate (closely)\nIf you and a peer are working closely on a analysis it may be appropriate for the owner to add their peer as a collaborator to the project. This is a point-and-click task from your github repository page (Settings>Collaborators>Add people>keypunch the username). The collaboator you can push and pull changes to their remote as if you were the owner. This arraignment is only appropriate for peers who you trust to commit changes of which you both approve. In practice this likely means there will be personal communication to coordinate each persons efforts.\n\n\n3.0.2.3 fork - To Collaborate (with autonomy)\nFork is a GiHub operation which creates a copy of a remote repository under your Github ID. After the fork is created you can clone it to you local repository as described above. Your local repository can be configured to sync with the original (upstream) repository so that you local repository contains changes the original author made after fork. If you make significant changes to the repository that the original author may be interested in you can submit a pull request which notifies the original author about the changes you have made and gives them the opportunity to include your code in their repository.\n\n\n\n\n\n\n\nI hope your analysis is on the network and you could use vpn to solve this problem.↩︎\nCommon courtesy requires you to ask permission and credit the person who originally wrote the code.↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ADF&G Division of Sport Fisheries Introduction to Git",
    "section": "",
    "text": "Preface\nThe author is aware that each analyst has a unique level of expertise and each analysis has unique requirements. As the analyist it is up to you to use professional judgment to decide which techniques are useful for the analysis you are conducting. That said, we offer the following general advice."
  },
  {
    "objectID": "index.html#division-of-sport-fish-github-transition",
    "href": "index.html#division-of-sport-fish-github-transition",
    "title": "ADF&G Division of Sport Fisheries Introduction to Git",
    "section": "Division of Sport Fish Github Transition",
    "text": "Division of Sport Fish Github Transition\nBiometricans with ADF&G Sport fish will be required to store their analysis on github starting in 2024. This means that all operations plans and reports published in 2024 and later will be required to reference a github site and a specific commit where the published analysis is stored. This decision was reached by a consensus of Biometrican IIIs and will streamline final biometric reviews and transitioning projects between biometrics staff. This document was produced to help provide guidance for satisfying this requirement."
  }
]