[
  {
    "objectID": "collaboration.html#section",
    "href": "collaboration.html#section",
    "title": "3  Collaboration Using Git",
    "section": "3.1 ",
    "text": "3.1"
  },
  {
    "objectID": "intro.html#what-does-git-do",
    "href": "intro.html#what-does-git-do",
    "title": "1  Introduction",
    "section": "1.1 What does Git do?",
    "text": "1.1 What does Git do?\nGit offers a way to track changes is your analysis without requiring the analyst to create different versions of the same file. To use git an analyst initializes their working directory (hopefully an R project). Files involved in the analysis (data, scripts, functions, model code) are added to the ask git to track changes associated with each file. When the analyst makes a commit, a snapshot of all tracked files at a specific point in time are recorded along with a message describing the commit and a automatically assigned a unique identifier. The analysis can also tag important commits. Because you can checkout prior commits this system duplicates file versioning with a structured system while ensuring the all commits are documented and the most important commits are easily identifiable.\nThe collection of all the commits, messages, tags and identifiers associated with a projects is called a repository. When a repository is created on your computer or private/company network it is local. An analyst can push a local repository to a remote repository (stored on the cloud). Alternatively, the analyst can pull a remote repository to their computer or private/company network to either create or update a local repository. Because multiple local repositories can push and pull to the same remote git allows collaboration between analysts which maintains the documentation and unique identifier features. Github is the most popular hosting service facilitating these collaborative features of git."
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "2  The Basic Git Workflow",
    "section": "",
    "text": "Herein we will focus on learning Git using the Terminal. The terminal is the easiest to demonstrate in a text document and everything you need to do can be done in the terminal. I’ll demonstrate the most important commands in the text that follows. In order to use the terminal effectively it helps to make one change to the Rstudio defaults by executing the following point and click commands: Tools>Terminal>Terminal Options…>(change initial directory to ‘project directory’). This change will ensure your terminal opens in the correct directory and save some unnecessary terminal prompts.\nThat said, many users find it easier to interact with Git through a graphical user interface (GUI). The most accesible is found in RStudio itself. A Git tab will show up in the Environment/History/Connections/Tutorial window provided your directory is a Git repository. Using a GUI that can save a lot of keystrokes for simple commands and often displays revisions more clearly that they are displayed in the shell. The drawbacks are that some commands can only be completed in the terminal, each GUI different, and point and click commands are difficult to demonstrate in a text document. For this reason, we will focus on the terminal but show how to complete each command in the Rstudio GUI in the appendix. In practice, I tend to work with a combination of the terminal and the Rstudio GUI.\n\n2.0.1 git init\nIf you have an existing Rstudio project1 that needs to become a git repository git init is the appropriate command. In the example below I have a Rstudio project in a folder named “git_practice” on S drive under S:/RTS/Reimer/Research_best_practices. In the terminal, each command line prompt ($) is proceeded by the username, shell type, and directory location.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice\n$\n\nThe terminal session below shows 3 commands and the output received after each command: 1) verify the directory is not a git repository with git status, 2) make is a git repository with git init, 3) verify the directory is now a git repository with git status.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice\n$ git status\nfatal: not a git repository (or any of the parent directories): .git\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice\n$ git init\nInitialized empty Git repository in //dfg.alaska.local/DSF/Anchorage/RTS/Reimer/Research_Best_Practices/git_practice/.git/\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git status\nOn branch {main}\n\nNo commits yet\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n        .gitignore\n        git_practice.Rproj\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$\n\nThe git init command creates a git repository in your project directory. At this point, the repository is empty, but the git workflow has been enabled which will allow us to commit to the repository in the future. The rounded rectangle in Figure 2.1 indicates all of the files included in your analysis at this point in time. At the moment they are represented by an empty rectangle which indicates that the files in your working directory are in a git work space. We will build this figure as we complete tasks within the Git work space.\n\n\n\n\n\nFigure 2.1: The Git workspace after you have initilized a repository.\n\n\n\n\n\n\n2.0.2 git add\nIn the last git status report shown above 2 files (.gitignore and git_practice_A.Rproj) were noted that could be added to the repository. Before we do that let’s create third file named fib_seq.R which contains a single line of code fib_seq <- c(0, 1). The Fibonacci sequence is the sequence created when each value in the sequence is the sum of the 2 previous values in the sequence and the vector c(0, 1) initializes the sequence. We will add to this sequence to practice the use of git. The terminal session below shows 5 commands: 1) view which files need to be added with git status, 2) add each file one at a time with git add, 3) verify all files have been added with git status. Notice that I made a typo while attempting to add the .Rproj file. I survived this catastrophe with a warning, which is typical of mistakes in the terminal.\n\n$ git status\nOn branch {main}\n\nNo commits yet\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n        .gitignore\n        fib_seq.R\n        git_practice.Rproj\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git add .gitignore\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git add fib_seq.R\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git_add git_practice.Rproj\nbash: git_add: command not found\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git add git_practice.Rproj\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git status\nOn branch {main}\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n        new file:   .gitignore\n        new file:   fib_seq.R\n        new file:   git_practice.Rproj\n\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$\n\nUse of git add stages files you would like to track for inclusion in your git repository. The rectangle in Figure 2.2 is now filled which indicates that files within your working directory are staged and ready to be committed.\n\n\n\n\n\nFigure 2.2: The Git workspace after you have staged files in your working directory which you intend to add to your local repository.\n\n\n\n\nNotice Git tells you how to unstage a file if you added one inadvertently. On occasion there are files in your working directory which you do not want Git to track. Examples might be .pdf files for literature you referencesd while conducting the analysis, word documents you produced for operational planning and reporting, or extreamly large outputs. It’s fine to exclude these sort of files but before you do so consider… “Would a future researcher need access to this file to recreate my work?”. If they would you should add them to the repository.\nTt can be cumbersome to have a long list of files which Git recognizes as present in your working directory but you are not actively tracking. The solution is to open the file .gitignore and identify the files you do not want to track. You can use wildcards if you prefer not to track all files of a certain type and or specify folders if you don’t want to track anything in certain sub-directories. For example, *.xlsx would ignore all .xlsx files in your working directory while posts/ would ignore all of the files in the folder posts within your working directory.\n\n\n2.0.3 git commit\nIn the git status response above 3 files were staged. Let’s commit those files in the terminal. In the terminal session above we verified all of the files we wanted to commit were staged using git status, recorded (committed) all of the staged files into the repository using git commit, verified the commit worked using git status and examined the repository log using git log.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git status\nOn branch {main}\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n        new file:   .gitignore\n        new file:   fib_seq.R\n        new file:   git_practice.Rproj\n\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git commit -m \"Initialize Fibonacci sequence\" -m \"Sequential additions to the Fibonacci sequence will provide a simple way to demonstrate several cycles of the git workflow including add/commit, push/pull, collaborate, fork, branch, merge, merge conflicts, exc. I even got my wife a GitHub account for this. Wish us luck!\"\n[{main} e17181f] Initialize Fibonacci sequence\n Date: Sun Jul 2 12:59:06 2023 -0800\n 3 files changed, 21 insertions(+)\n create mode 100644 .gitignore\n create mode 100644 fib_seq.R\n create mode 100644 git_practice.Rproj\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git status\nOn branch {main}\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git log\ncommit e17181fa781b2e30096e1c7d31443aac18d527e5 (HEAD -> {main})\nAuthor: Adam Reimer <adam.reimer@alaska.gov>\nDate:   Sun Jul 2 12:59:06 2023 -0800\n\n    Initialize Fibonacci sequence\n\n    Sequential additions to the Fibonacci sequence will provide a simple way to demonstrate several cycles of the git workflow including add/commit, push/pull, collaborate, fork, branch, merge, merge conflicts, exc. I even got my wife a GitHub account\nfor this. Wish us luck!\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$\n\nGit log provides a summary of the commit. Two important parts are the commit ID and the commit message. The commit ID is a code which can be used to reference the commit in the future. Git assigned a long ID to each commit e17181fa781b2e30096e1c7d31443aac18d527e5 for this commit, but its common to using only the first 7 characters of the commit ID e17181f to refer to a commit.\nCommit messages are required. Notice the commit message is broken into 2 parts. The first part is called the title or summary while the second part is called the description. A good practice is for the title to be brief (less that 50 characters) so that it displays well in most formats. There is no length limit for the description and this is the place to provide some explanation beyond what you can capture in the title. I’ve purposely been more verbose that typical with this commit to demonstrate a long description.\n\n\n\n\n\nFigure 2.3: The Git workspace after you have committed your staged files to your local repository.\n\n\n\n\nThe git workflow described so far forms the basis on reproducible research using Git. In our example we will calculate the next several values in the Fibonacci sequence to practice this workflow. After a change is made and saved to the working directory your Git workspace will look something like:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.0.3.1 When to Commit?\nSaves and a commits serve different purposes. As we all know, save can and should be used frequently… many times an hour and/or any time you are stepping away from your work. This use is agnostic to whether the analysis is using a traditional or git workflow.\nIn contrast, commits are made for two reasons. First, a commit should be made whenever the analysis is at a point which you may want to revisit. Examples include; adding new data, adding a new component to the analysis, or any time the code was run and the results were distributed. Any one of these tasks may have resulted in a new ‘version’ in the traditional workflow but they don’t have to be major updates. The commit may also snapshot significant steps in a new features development or prior to experimenting with a new feature. These commits allow you to revert back to the previous code in the event the new feature is not an improvement. A second reason to commit is when the changes are substantive enough that the line-by-line change may be difficult to track if you did not commit until the new data/feature are complete.\nThe most important thing to note regarding commit messages is that, unlike save, there is no temporal component. While saves are designed to minimize the risk of lost work and should be frequent in time, commits are designed to record importance stages of the analysis and commits should be frequent with respect to progress. A difficult feature may take days to code but represent a single commit, provided the actual changes to the code are modest. Efficiency in commit frequency pay off when a large repository is being revisited at a later date.\n\n\n\n2.0.4 git log\nThe view our commit history in the terminal use git log. For this example, I have not been including descriptions with my commit messages became the changes were simple enough to describe in the title. Note that the commit ID, author, dat, commit title and commit description are all shown in the log.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git log\ncommit 11cf98ff67b8ec4f8cd7f2c1650a176d5875fdcf (HEAD -> {main})\nAuthor: Adam Reimer <adam.reimer@alaska.gov>\nDate:   Sun Jul 2 14:53:05 2023 -0800\n\n    Fourth entry in the Fibonacci sequence\n\n    Long and informative message goes here.\n\ncommit 3bb6c98bb0048bad7bda489bd8d40be24fb66acf\nAuthor: Adam Reimer <adam.reimer@alaska.gov>\nDate:   Sun Jul 2 14:31:04 2023 -0800\n\n    Third entry in fib_seq\n\n    This message is not necessary for such a simple commit, but descriptions are an important part of reproducible research I’m writing a long message to set a good example.  Have better content in yours.\n\ncommit e17181fa781b2e30096e1c7d31443aac18d527e5\nAuthor: Adam Reimer <adam.reimer@alaska.gov>\nDate:   Sun Jul 2 12:59:06 2023 -0800\n\n    Initialize Fibonacci sequence\n\n    Sequential additions to the Fibonacci sequence will provide a simple way to demonstrate several cycles of the git workflow including add/commit, push/pull, collaborate, fork, branch, merge, merge conflicts, exc. I even got my wife a GitHub account\nfor this. Wish us luck!\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$\n\n\n\n2.0.5 git diff\nTo seee the difference between two commits use git diff. With no additional arguments git diff will show the changes in the working directory relative to the last commit. Our working directory has no changes as illustrated by git status. Instead we can add a short commit ID to the command to see changed between the current working directoy and the commit 3bb6c9.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git status\nOn branch {main}\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git diff 3bb6c9\ndiff --git a/fib_seq.R b/fib_seq.R\nindex 9c118d5..4ce1d70 100644\n--- a/fib_seq.R\n+++ b/fib_seq.R\n@@ -2,4 +2,5 @@\n #Adam Reimer\n\n fib_seq <- c(0, 1)\n-fib_seq[3] <- fib_seq[1] + fib_seq[2]\n\\ No newline at end of file\n+fib_seq[3] <- fib_seq[1] + fib_seq[2]\n+fib_seq[4] <- fib_seq[2] + fib_seq[3]\n\\ No newline at end of file\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$\n\nGit GUI’s are superior to the terminal when looking at line-by line differences but for completeness we will discuss how to read the output. The section --- a/fib_seq.R to +++ b/fib_seq.R identifies the files that were modified where --- a/ and +++ b refer to the previous and the current versions of the file respectively. The line @@ -2,4 +2,5 @@ tells us that the output is showing the original file starting on the second line and displaying the the next 4 lines (three unmarked lines and the line with a negative symbol) while the new version of the file is also shown starting from the second line but displaying the next 5 lines (the three unmarked lines and the two lines with a addition symbol). This makes sense because a single line was added to the new version.\n\n\n\n\n\n\nside note: if you have an existing project directory that needs to become an Rstudio project the appropriate point and click sequence is New Project>Existing Directory>(provide location)↩︎"
  },
  {
    "objectID": "advanced.html",
    "href": "advanced.html",
    "title": "4  Advanced Git Workflow",
    "section": "",
    "text": "Advanced Git workflows introduce some new concepts like reverting to a previous version and several skill which can help a researcher develop models/analysis including branching, merging and branch strategies. These concepts are likely overkill for simple analysis but can because very helpful for large projects.\n\n4.0.1 git checkout (HEAD~# or SHA key)\nTo recall a previous commit use git checkout and provide the SHA for the commit you wish to recall. You will receive and error message telling you GIT is in a detached HEAD state which simply means GIT is confused on which commit it should be considering the most recent; the commit you checked out or the last commit you made. Git tells you how to navigate this condition. If you only want to see the old code but not use it you can do that and simple checkout the most recent commit when you are done. I you want to revert to the old code the correct technique is to create a new branch and merge it back with the old branch accepting the code form each branch.\nWhile making this book I realized I may have inadvertently deleted a file I need. In the terminal sequence below shows how I repaired that problem. First I used git checkout to revert to my work space during the last commit (HEAD~1 is shorthand for 1 commit prior). I cut and pasted the files I needed, they magically appeared in my working directory because I had add/committed them earlier, and attempted git switch to reverted back to the most recent commit. This didn’t work so I tried git checkout 57ba5a3d which allowed me to explicitly state the commit I wanted to go to using the SHA key 57ba5a3d, which also failed to work. At that point I shut down all files/windows that referenced anything to do with this project (this is a common problem with Git… something to do with Windows only allowing one application to access each file at a time. After that I was able to checkout the most current commit and reattach the head.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book (master)\n$ git checkout HEAD~1\nUpdating files: 100% (30/30), done.\nNote: switching to 'Head~1'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by switching back to a branch.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -c with the switch command. Example:\n\n  git switch -c <new-branch-name>\n\nOr undo this operation with:\n\n  git switch -\n\nTurn off this advice by setting config variable advice.detachedHead to false\n\nHEAD is now at 27bd7c8 Initial commit\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book ((27bd7c8...))\n$ git switch -\nerror: cannot stat '_book/collaboration_files': Permission denied\nerror: cannot stat '_book/collaboration_files': Permission denied\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book ((27bd7c8...))\n$ git checkout 57ba5a3d\nerror: cannot stat '_book/collaboration_files': Permission denied\nerror: cannot stat '_book/collaboration_files': Permission denied\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book ((27bd7c8...))\n$ git status\nHEAD detached at 27bd7c8\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book ((27bd7c8...))\n$ git checkout 57ba5a3d\nUpdating files: 100% (30/30), done.\nPrevious HEAD position was 27bd7c8 Initial commit\nHEAD is now at 57ba5a3 draft collab chapter/general updates\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book ((57ba5a3...))\n$ git status\nHEAD detached at 57ba5a3\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book ((57ba5a3...))\n$ git checkout master\nSwitched to branch 'master'\n\n\n\n\n\n\n4.0.2 git checkout -b new_branch_name old_branch-name\nI like to think of branches as a line of model development. A best practice is to create a new branch any time you are experimenting with a new feature that you are not sure you want/need or that you think may take several commits to complete."
  },
  {
    "objectID": "RStudio.html#section",
    "href": "RStudio.html#section",
    "title": "Appendix A — The RStudio Graphical User Interface",
    "section": "A.1 ",
    "text": "A.1"
  },
  {
    "objectID": "collaboration.html",
    "href": "collaboration.html",
    "title": "3  Collaboration Using Git",
    "section": "",
    "text": "Git has some amazing reproducible research capabilities that can become really powerful in large complicated analyses. That said, utilizing Git comes with an overhead that may not be justified for small projects unless you consider collaboration with future analysts including yourself. To utilize Git’s collaborative potential create a remote repository on github. I created one called git_practice.\n\n3.0.1 Interacting with your Remote Repository\n\n3.0.1.1 git push\nTo link your local repository to a remote repository use git remote. In the terminal session below I added a remote repository named “origin” and provided a url where the repository is located. The second command created a new branch in the remote names “main”. The third command “pushed” my local repository to my remote repository. Files associated with this repository are now stored in a location where they can be accessed by others for viewing, download, or collaborative work.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git remote add origin https://github.com/adamreimer/git_practice.git\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git branch -M main\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git push -u origin main\nEnumerating objects: 11, done.\nCounting objects: 100% (11/11), done.\nDelta compression using up to 16 threads\nCompressing objects: 100% (10/10), done.\nWriting objects: 100% (11/11), 1.53 KiB | 8.00 KiB/s, done.\nTotal 11 (delta 2), reused 0 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (2/2), done.\nTo https://github.com/adamreimer/git_practice.git\n * [new branch]      main -> main\nbranch 'main' set up to track 'origin/main'.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$\n\nAfter pushing to github your repository now looks like Figure 3.1.\n\n\n\n\n\nFigure 3.1: The Git workspace after your local repository has been pushed to a remote repository.\n\n\n\n\nNow that we have a remote repository updated we have to worry about keeping them both synced. To illustrate this workflow I’ll change the fib_seq.r file by adding the fifth value to the Fibonacci sequence. After this change the git work space will contain unstaged changes which are not reflected in either repository.\n\n\n\n\n\nFigure 3.2: The Git workspace after the working directory has been changed leaving the local and remote repositories out-of-date.\n\n\n\n\nIn the terminal session below I stage the file fib_seq.R and commit the file. Notice the first time we submitted a git status command we were told the local and remote repositories were synced but that there were unstaged changes. After the modified file was added and committed the second call to git status tells us our remote repository is one commit behind our local repository. The git work space at this moment is illustrated by Figure 3.3.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   fib_seq.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git add fib_seq.R\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git commit -m \"Fifth entry in the Fibonacci sequence\" -m \"A long and descriptive description\"\n[main 5139049] Fifth entry in the Fibonacci sequence\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git status\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$\n\n\n\n\n\n\nFigure 3.3: The Git workspace after a local change has been staged & committed leaving the remote repositories one commit behind.\n\n\n\n\nIn the terminal session below I use git push to update the remote repository. Notice git status verifies the repositories are now synced. The git work space at this moment is illustrated by Figure 3.4.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git push\nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 16 threads\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 414 bytes | 8.00 KiB/s, done.\nTotal 3 (delta 1), reused 0 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (1/1), completed with 1 local object.\nTo https://github.com/adamreimer/git_practice.git\n   0c92881..5139049  main -> main\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$\n\n\n\n\n\n\nFigure 3.4: The Git workspace after a local change has been staged, committed, and pushed.\n\n\n\n\n\n\n3.0.1.2 git clone\nImagine a situation where you would like to work on your analysis from a home computer1. If your analysis is stored as a git repository it is easy to obtain a copy from a different computer. In the terminal sequence below we navigate to my home computer’s C drive, clone the remote repository to the C drive, navigate to the new local repository, and check the repository status. Notice that I made a typo on the git status command the first time and nothing terrible happened.\n\namreimer@DFGSXQDSF223076 MINGW64 ~/Documents\n$ cd C:/\n\namreimer@DFGSXQDSF223076 MINGW64 /c\n$ git clone https://github.com/adamreimer/git_practice.git\nCloning into 'git_practice'...\nremote: Enumerating objects: 14, done.\nremote: Counting objects: 100% (14/14), done.\nremote: Compressing objects: 100% (10/10), done.\nremote: Total 14 (delta 3), reused 14 (delta 3), pack-reused 0\nReceiving objects: 100% (14/14), done.\nResolving deltas: 100% (3/3), done.\n\namreimer@DFGSXQDSF223076 MINGW64 /c\n$ cd C:/git_practice\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git_status\nbash: git_status: command not found\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$\n\nAfter git clone the my remote repository to my home machine I have two local repositories associated with the same remote(see Figure 3.5).\n\n\n\n\n\nFigure 3.5: The Git workspace when you have two local repositories associated with the same remote.\n\n\n\n\nChanges made to the local repository on my C drive, which are staged, committed and pushed to the remote will cause the local repository on my S drive to be behind one commit. The terminal session below demonstrated these commands (all of which we have seen before) and the current state of the Git work space is shown in Figure 3.6.\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   fib_seq.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git add fib_seq.R\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git commit -m \"Sixth number in the Fibonacci seqence\" -m \"This commit is slightly different as it was made from a different computer in my house. It still represents a single author working on their own repository but demonstrated the flexibility accorded by storing your analysis on the cloud. Working on this analysis from a new machine was seamless provided the new machine had the appropriate software.\"\n[main 9db5478] Sixth number in the Fibonacci seqence\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git status\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git push\nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 16 threads\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 586 bytes | 586.00 KiB/s, done.\nTotal 3 (delta 1), reused 0 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (1/1), completed with 1 local object.\nTo https://github.com/adamreimer/git_practice.git\n   5139049..9db5478  main -> main\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$\n\n\n\n\n\n\nFigure 3.6: The Git workspace when you have one local repository has pushed a new commit to the remote repository.\n\n\n\n\n\n\n3.0.1.3 git pull\nAs Figure 3.6 demonstrate the local repository on my S drive is now one commit behind the remote (and the local repository on my C drive). In the terminal session below we try git status but are told the local and remote repositories are synced, which we know to be false. Git has lost track of the remote since the repository on the S drive was blind to the last commit. Instead we use git update to update the remote connection, after which git status works as before. Finally, git pull brings the local repository on the S drive into sync with the remote. At this point the local and remote repositories have the structure of Figure 3.5 but will include an additional commit (9db5478) not shown in Figure 3.5.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git remote update\nremote: Enumerating objects: 5, done.\nremote: Counting objects: 100% (5/5), done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0\nUnpacking objects: 100% (3/3), 566 bytes | 0 bytes/s, done.\nFrom https://github.com/adamreimer/git_practice\n   5139049..9db5478  main       -> origin/main\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git status\nOn branch main\nYour branch is behind 'origin/main' by 1 commit, and can be fast-forwarded.\n  (use \"git pull\" to update your local branch)\n\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git pull\nUpdating 5139049..9db5478\nFast-forward\n fib_seq.R | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$\n\n\n\n\n3.0.2 Interacting with a Peer’s Remote Repository\nHow you interact with a peers remote repository depends on your goals. We will discuss three typical use cases below.\n\n3.0.2.1 git clone - To Copy/Modify Code\nImagine a situation where a peer has some code written which you would like to modify for a similar project2. Use git clone as described above. You will be able to create a copy of their repository and work on your local machine as usual, but you will not be able to push changes back to the remote.\n\n\n3.0.2.2 git clone, git push, git pull - To Collaborate (closely)\nIf you and a peer are working closely on a analysis it may be appropriate for the owner to add their peer as a collaborator to the project. This is a point-and-click task from your github repository page (Settings>Collaborators>Add people>keypunch the username). The collaborator can push and pull changes to the remote as if they were the owner. This arraignment is only appropriate for peers who you trust to commit changes of which you both approve. In practice, this likely means there will be personal communication to coordinate each person’s efforts. To demonstrate this process I added my wife (Carly) as a collaborator to the git_practice repository. Carly then modified the fib_seq.R file, added the file, committed the changes, and pushed her version of the local repository back to the git_practice remote. Afterwards I pulled those changes back to my version of the local repositry. The terminal sessions and figures associated with these actions would closely mirror those shown for git clone, git push, and git pull above although the local repositories have different owners in this case. To demonstrate commits were made byt both collaborators I ran a specially formatted call3 to git log which shows that the latest commit to this repository did come form a new author.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git log --pretty=format:\"%h%x09%an%x09%ad%x09%s\"\nf732cdb Carly Reimer    Sun Jul 2 22:01:17 2023 -0800   Seventh Fibonacci number\n9db5478 Adam Reimer     Sun Jul 2 20:39:19 2023 -0800   Sixth number in the Fibonacci seqence\n5139049 Adam Reimer     Sun Jul 2 16:15:52 2023 -0800   Fifth entry in the Fibonacci sequence\n0c92881 Adam Reimer     Sun Jul 2 14:53:05 2023 -0800   Fourth entry in the Fibonacci sequence\n3bb6c98 Adam Reimer     Sun Jul 2 14:31:04 2023 -0800   Third entry in fib_seq\ne17181f Adam Reimer     Sun Jul 2 12:59:06 2023 -0800   Initialize Fibonacci sequence\n\n\n\n3.0.2.3 fork - To Collaborate (formally)\nFork is a GitHub operation which creates a copy of another users remote repository under your Github ID. After the fork is created you can clone it to a local repository as described above. Your local repository can be configured to sync with the original (upstream) repository so that you local repository contains changes the original author made after fork. If you make significant changes to the repository that the original author may be interested in you can submit a pull request which notifies the original author about the changes you have made and gives them the opportunity to include your code in their repository. Github has great documentation of this process.\nAs an example I revoked my wife’s (Carly) collaborator status on the git_practice repository associated with my GitHub account. Carly then forked the git_practice repository in my account. Afterwards, the forked version of the git_practice repository on her account looked something like this:\n\n\n\nThe forked git_practice repository in Carly Reimer’s GitHub account\n\n\nUsing the same commands describe above Carly cloned the forked repository, made changes, added the changed file, committed the changes, and pushed the result back to her forked repository on Github. Pull requests are so named because Carly is asking me to pull her forked repository back into my version. Pull requests are initiated by the person making the request from the original repository. The pull request looked like this from my account:\n\n\n\nThe pull request summary screen.\n\n\nNavigating the the Files changed allows the repository owner to review line by line changes associated with the request. In this case I deemed the suggestions reasonable and accepted them without comment but there are capabilities to submit comments and request changes before the changes are accepted.\n\n\n\nThe pull request review/approval screen\n\n\nAfter the request is approved the original owner can merge the pull request from within GitHub.\n\n\n\nMerging a pull request\n\n\n\n\n\n\n\n\n\nI hope your analysis is on the network and you could use vpn to solve this problem.↩︎\nCommon courtesy requires you to ask permission and credit the person who originally wrote the code.↩︎\nThanks Jesper Rønn-Jensen! Note: %h specifies the short commit ID, %x09 specifies a tab, %an specifies the author, %ad specifies the commit date, and %s specifies the commit title.↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ADF&G Division of Sport Fisheries Introduction to Git",
    "section": "",
    "text": "Preface\nThe author is aware that each analyst has a unique level of expertise and each analysis has unique requirements. As the analyist it is up to you to use professional judgment to decide which techniques are useful for the analysis you are conducting. That said, we offer the following general advice."
  },
  {
    "objectID": "index.html#division-of-sport-fish-github-transition",
    "href": "index.html#division-of-sport-fish-github-transition",
    "title": "ADF&G Division of Sport Fisheries Introduction to Git",
    "section": "Division of Sport Fish Github Transition",
    "text": "Division of Sport Fish Github Transition\nBiometricans with ADF&G Sport fish will be required to store their analysis on github starting in 2024. This means that all operations plans and reports published in 2024 and later will be required to reference a github site and a specific commit where the published analysis is stored. This decision was reached by a consensus of Biometrican IIIs and will streamline final biometric reviews and transitioning projects between biometrics staff. This document was produced to help provide guidance for satisfying this requirement."
  },
  {
    "objectID": "intro.html#how-do-i-interact-with-git",
    "href": "intro.html#how-do-i-interact-with-git",
    "title": "1  Introduction",
    "section": "1.2 How do I interact with Git?",
    "text": "1.2 How do I interact with Git?\nOne problem with widespread adoption of Git at ADF&G is that there is no accepted standard for how to interact with Git. The options are a (graphical user interface) GUI or terminal. Herein, we will focus on how to use Git while interacting through the terminal. We make this choice for 3 reasons. First, because the terminal is a command line interface it is easy to demonstrate the exact steps that were taken to achieve each outcome. Throughout this document you will find code blocks (identifiable by a grey bar along the left hand margin) which show the command line prompt, the command given and the result received for each action demonstrated. This presentation is more concrete that hundreds of screenshots with certain buttons highlighted. A second point is that there are a lot of GUI’s out there. I will include an appendix which shows how to do the most common git functions in Rstudio which is not a very powerful Git GUI but sufficient for most tasks and readily available for most readers of this book. Perhaps someone else has a GUI they highly recommend and would like to included a second appendix with a tutorial about how to intact with it. Fork the repository associated with this book, add an appendix with instructions for your GUI and submit a pull request… instructions on how to do so are included! A final reason to use command line in the context of this book is that the command line prompts for the basis for all the GUI’s that are available. In general, if your Google how to complete a odd Git task you will be told how to do so in command line, so it is good to have some familiarity with that interface. Rest assured, I don’t use the terminal to interact with Git the majority of the time1 and I don’t recommend you do either. But I do think you will end up there eventually, that the terminal has pedagogical advantages and that if you can use the terminal GUI’s are easier to understand.\nIn order to use the terminal effectively it helps to make one change to the Rstudio defaults by executing the following point and click commands: Tools>Terminal>Terminal Options…>(change initial directory to ‘project directory’). This change will ensure your terminal opens in the correct directory and save some unnecessary terminal prompts."
  },
  {
    "objectID": "intermediate.html",
    "href": "intermediate.html",
    "title": "4  Intermediate Git Workflow",
    "section": "",
    "text": "Intermediate Git workflows introduce some new concepts like reverting to a previous version and several skills which can help a researcher develop models/analysis including branching, merging and branch strategies. These concepts are likely overkill for simple analysis but can be very helpful for large projects.\n\n4.0.1 git branch\nIn Git a branch is a pointer to a specific commit or set of commits which allow you to separate model development tasks into individual work units. Everything I know about branching I learned from this guy and in what follows I will simplify his workflow into something that works well for complicated fisheries analyses. Let’s start by creating a new branch in our git_practice directory. In the Git session below we create a new branch named develop, switch to that branch, make changes, add/stage those changes, commit those changes.\n\n\n\nThe development branch is now one commit ahead of the main branch. Additional commits can be made, to either branch. In the Git session below we create switch to the main branch, make different changes, add/stage those changes, commit those changes.\n\n\n\nNow let’s take a look at snapshot of the file fib_seq.R in each of the two branches. They differ, and this is entirely appropriate, as it allows us to separate model development. Having a branching strategy is the key to how to use branches to coordinate and combine model development tasks.\n\n4.0.1.1 Branching strategy\nThe core concept in the GitFlow branching strategy is to have two main bracnhs; main and develop. The main branch is associated with collaboration in that you make limited commits to the main branch with those snapshots associated with internal or external reporting; including FDS reports, BOF memos or work sessions, or conference presentations. Becasue the main branch will largely be static interested collaborators can quickly identify the analysis at the time periods where the analysis was reported.\nThe develop branch is the main working branch and will have frequent commits relative to analysis progress and merge into the master branch when the analysis is reported.\nFeature branches are created frequently as new features are envisioned and developed. A best practice is to create a new feature branch, with a descriptive name, every time your create a new feature. When the feature is completed it is merged back into develop, left as a record without a merge, or deleted. In my work, feature branches are mostly merged back into develop, and this occurs whenever I created a feature which I beleive improves the analysis. Feature branches are left unmerged when I want to retain a record of having tried something (and the result) but do not think it improves the overall analysis. Feature branches are deleted without merging when something just did not work out and also not worth retaining as a record.\n\n\n\n4.0.2 git merge\n\n\n4.0.3 git checkout (HEAD~# or SHA key)\nTo recall a previous commit use git checkout and provide the SHA for the commit you wish to recall. You will receive and error message telling you GIT is in a detached HEAD state which simply means GIT is confused on which commit it should be considering the most recent; the commit you checked out or the last commit you made. Git tells you how to navigate this condition. If you only want to see the old code but not use it you can do that and simple checkout the most recent commit when you are done. I you want to revert to the old code the correct technique is to create a new branch and merge it back with the old branch accepting the code form each branch.\nWhile making this book I realized I may have inadvertently deleted a file I need. In the terminal sequence below shows how I repaired that problem. First I used git checkout to revert to my work space during the last commit (HEAD~1 is shorthand for 1 commit prior). I cut and pasted the files I needed, they magically appeared in my working directory because I had add/committed them earlier, and attempted git switch to reverted back to the most recent commit. This didn’t work so I tried git checkout 57ba5a3d which allowed me to explicitly state the commit I wanted to go to using the SHA key 57ba5a3d, which also failed to work. At that point I shut down all files/windows that referenced anything to do with this project (this is a common problem with Git… something to do with Windows only allowing one application to access each file at a time. After that I was able to checkout the most current commit and reattach the head.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book (master)\n$ git checkout HEAD~1\nUpdating files: 100% (30/30), done.\nNote: switching to 'Head~1'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by switching back to a branch.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -c with the switch command. Example:\n\n  git switch -c <new-branch-name>\n\nOr undo this operation with:\n\n  git switch -\n\nTurn off this advice by setting config variable advice.detachedHead to false\n\nHEAD is now at 27bd7c8 Initial commit\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book ((27bd7c8...))\n$ git switch -\nerror: cannot stat '_book/collaboration_files': Permission denied\nerror: cannot stat '_book/collaboration_files': Permission denied\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book ((27bd7c8...))\n$ git checkout 57ba5a3d\nerror: cannot stat '_book/collaboration_files': Permission denied\nerror: cannot stat '_book/collaboration_files': Permission denied\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book ((27bd7c8...))\n$ git status\nHEAD detached at 27bd7c8\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book ((27bd7c8...))\n$ git checkout 57ba5a3d\nUpdating files: 100% (30/30), done.\nPrevious HEAD position was 27bd7c8 Initial commit\nHEAD is now at 57ba5a3 draft collab chapter/general updates\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book ((57ba5a3...))\n$ git status\nHEAD detached at 57ba5a3\nnothing to commit, working tree clean\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/Git_book ((57ba5a3...))\n$ git checkout master\nSwitched to branch 'master'\n\n\n\n\n\n\n4.0.4 git checkout -b new_branch_name old_branch-name\nI like to think of branches as a line of model development. A best practice is to create a new branch any time you are experimenting with a new feature that you are not sure you want/need or that you think may take several commits to complete."
  }
]