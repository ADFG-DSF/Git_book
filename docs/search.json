[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ADF&G Division of Sport Fisheries Introduction to Git",
    "section": "",
    "text": "Preface\nThis short book is intended to help Biometricians within the Division of Sport Fisheries learn the use of Git and GitHub as a reproducible research best practice. Git provides the professional Biometrican with two main tools: 1) It provides a way to keep track of previous versions of a file or set of files without having to rename the file and retain multiple closely related versions, and 2) it provides a way to make sure your analysis is discoverable to fellow researchers without requiring your direct involvement. These techniques are new but quickly becoming an industry standard.\nGit has more features than we need for fisheries research with most of the educational material out there being written by and for professional programmers. This book attempts to close that gap by demonstrating the most common features of a git workflow in more accessible language. Best practice documents tend to describe appropriate practices for the largest, most complex analyses you are likely to face. If your project is simple, the overhead associated with some of these techniques may not be justified. Use your professional judgment to discern how to follow the spirit of reproducible research while modifying this guidance to specific situations you encounter. There is an appendix describing the minimum requirements for ADF&G/DFG analysis.\nThe book is structured as follows.\n\nChapter 1 describes what Git is, how it can help our research projects, and conventions used within this book.\nChapter 2 describes the process and commands necessary to use Git to track changes within your working directory.\nChapter 3 describes using Git and GitHub to store your work on GitHub. In the chapter collaborators can take several meaning: you can collaborate with yourself by using GitHub to allow you modify your analysis from two locations, your can collaborate with a peer to improve each others analysis, and/or you can collaborate with your professional predecessor and descendants by keeping your analysis discoverable.\nChapter 4 introduces some higher overhead concepts that can be very helpful on large, complicated analysis which require significant model development.\nChapter 5 shows you how to retrieve previous versions of a file (or the entire analysis) from your Git repository.\nChapter 6 reminds us all to leave our analyses in a good place for the next person and/or our future self.\nAppendix A describes the RStudio Git graphical user interface (GUI).\nAppendix B synthesizes the concepts in this book into a minimum reproducible research standard for ADF&G DSF Biometricians."
  },
  {
    "objectID": "intro.html#what-does-git-do",
    "href": "intro.html#what-does-git-do",
    "title": "1  Introduction",
    "section": "1.1 What does Git do?",
    "text": "1.1 What does Git do?\nGit offers a way to track changes in your analysis without requiring the analyst to create different versions of the same file. To use git, an analyst initializes their working directory (hopefully an R project). Files involved in the analysis (data, scripts, functions, model code) are added so that git knows to track changes associated with each file. When the analyst makes a commit, a snapshot of all tracked files at that specific point in time are recorded along with a message describing the commit and an automatically assigned a unique identifier. The analyst can also tag important commits. Because you can checkout prior commits this system allows for traditional file versioning with a structured system while ensuring the all commits are documented and the most important commits are easily identifiable.\nThe collection of all the commits, messages, tags and identifiers associated with a projects is called a repository. When a repository is created on your computer or private/company network it is local. An analyst can push a local repository to a remote repository (stored on the cloud). Alternatively, the analyst can pull a remote repository to their computer or private/company network to either create or update a local repository. Because multiple local repositories can push and pull to the same remote repository Git allows collaboration between analysts while maintaining the documentation and unique identifiers associated with each commit. Github is the most popular hosting service facilitating these collaborative features of Git."
  },
  {
    "objectID": "intro.html#why-should-we-use-git",
    "href": "intro.html#why-should-we-use-git",
    "title": "1  Introduction",
    "section": "1.2 Why should we use Git?",
    "text": "1.2 Why should we use Git?\nGit is quickly becoming a standard reproducible research best practices. The Division of Sport Fisheries and it’s employees mutually benefit by developing skills with this tool. For the individual, use of Git helps:\n\nEasily share code with your colleagues.\nKeep a record of file modifications and versions with a line-by-line record without retaining multiple files.\nAllows for a cloud based platform which you can access from your desktop and laptop. This method is generally faster and more stable than vpn.\nModel development and the tracking of the model development process is made easier.\n\nFor ADF&G, use of Git provides:\n\nA shared organizational structure for ADF&G analyses flattens the learning curve when reviewing/inheriting a peer’s work.\nA shared space where current and future ADF&G employees can locate past and present analyses."
  },
  {
    "objectID": "intro.html#how-to-interact-with-git",
    "href": "intro.html#how-to-interact-with-git",
    "title": "1  Introduction",
    "section": "1.3 How to interact with Git?",
    "text": "1.3 How to interact with Git?\nOne challenge with widespread adoption of Git at ADF&G is that there is no accepted standard for how to interact with Git. The options are a GUI (graphical user interface) or a command line interface (terminal). Herein, we will focus on how to use Git while interacting through the terminal. We make this choice for 3 reasons. First, because the terminal is a command line interface it is easy to demonstrate the exact steps that were taken to achieve each outcome. This presentation is more concrete and robust to future changes than a parade of screenshots. A second issue is that there are a lot of GUIs out there. I will include an appendix which shows how to do the most common Git functions in RStudio. While not a particularly good Git GUI, the RStudio interface is sufficient for most tasks and readily available for most readers of this book. If you have a GUI you highly recommend we welcome your input. Please fork the repository associated with this book, add an appendix with instructions for your preferred GUI and submit a pull request… instructions on how to do so are included in the chapter on collaboration. A final reason to use command line in the context of this book is that the terminal commands are commonly described in Stack Overflow if you Google how to accomplish a task in Git. Rest assured, I don’t use the terminal to interact with Git the majority of the time1 and I don’t recommend you do either. But I do think you will end up there eventually, that the terminal has pedagogical advantages, and that if you can use the terminal the GUI’s are easier to understand.\nIn order to use the terminal effectively it helps to make one change to the Rstudio defaults by executing the following point and click commands: Tools&gt;Terminal&gt;Terminal Options…&gt;(change initial directory to ‘project directory’). This change will ensure your terminal opens in the correct directory and save some unnecessary terminal commands."
  },
  {
    "objectID": "intro.html#conventions-used-in-this-book",
    "href": "intro.html#conventions-used-in-this-book",
    "title": "1  Introduction",
    "section": "1.4 Conventions used in this book",
    "text": "1.4 Conventions used in this book\nThroughout this document you will find code blocks which show the command line prompt, the command given, and the result received for each action demonstrated. Code blocks are identifiable by a blue bar along the left hand margin and a grey background. In the terminal, each command line prompt ($) is preceded by a line which shows the username, shell type, and directory location. In the terminal session below we can see that the username was amreimer@DFGSXQDSF206801, the shell type was MING64 and the directory location was S:/RTS/Reimer/Research_Best_Practices/git_practice. User commands are keypunched after the command line prompt. In the terminal session below I entered the command git status. The line after the command line prompt returns the output received from the command. In this case, Git tells me that the directory S:/RTS/Reimer/Research_Best_Practices/git_practice is not a Git repository. In practice we will often run several terminal commands in a row although in this text each prompt and return will be presented as a separate code block to make it easier to discern each command and output.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice\n$ git status\nfatal: not a git repository (or any of the parent directories): .git\n\nWhen point and click sequences are referenced in this text button names will be shown in italic, button names in series will be separated by and the greater than symbol (&gt;) and any actions required will be described using (italics enclosed in parenthesis). For an example see the last paragraph of the preceding section.\nWhen git commands are referenced in the text they will be displayed as an inline code block. R objects and Git branches are also referenced as inline code blocks."
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "2  The Basic Git Workflow",
    "section": "",
    "text": "Basic Git use includes how to create a repository, track changes in the files within your repository, view your repository history, and view line by line changes in modified files. The title for each section in this chapter will be a basic Git command with the text, code blocks, and figures in each section describing the use and result for each command.\n\n2.0.1 git init\nIf you have an empty folder that you would like make a git repository git init is the appropriate command. In the example below I have an empty folder named “git_practice” on S drive under S:/RTS/Reimer/Research_best_practices. The terminal session below shows 3 commands and the output received after each command. The first command, git status is a general diagnostic of the Git repository. This command is commonly used when working in the terminal.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice\n$ git status\nfatal: not a git repository (or any of the parent directories): .git\n\nThe second command uses git init to make the working directory into a Git repository.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice\n$ git init\nInitialized empty Git repository in //dfg.alaska.local/DSF/Anchorage/RTS/Reimer/Research_Best_Practices/git_practice/.git/\n\nThe third command used git status to verify the working directory is now a git repository.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git status\nOn branch {main}\n\nNo commits yet\n\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n        .gitignore\n        git_practice.Rproj\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\nThe git init command creates a git repository in your project directory. To help conceptualize the use of Git we will be developing a series of figures to demonstrate how files are introduced into the workflow and move through the Git work space once there. At this point, a few files are in the working directory and while a repository has been created we have yet to commit anything to the repository. The rounded rectangle in Figure 2.1 indicates the contents of your working directory at this point in time. At the moment they are represented by an empty rectangle which indicates that the files in your working directory have yet to be staged. We will build this figure as we complete tasks within the Git work space.\n\n\n\n\n\nFigure 2.1: The Git workspace after you have initilized a repository.\n\n\n\n\n\n\n2.0.2 git add\nIn the last git status report shown above 2 files (.gitignore and git_practice.Rproj) were noted that could be added to the repository. Before we do that let’s create third file named fib_seq.R which contains a brief header and a single line of code fib_seq &lt;- c(0, 1). The Fibonacci sequence is the sequence created when each value in the sequence is defined as the sum of the 2 previous values in the sequence and the vector c(0, 1) initializes the sequence. We will add to this sequence to practice the use of Git. The terminal session below shows 5 commands necessary to add or stage the files in our working directory. You stage a file when you would like Git to keep track of changes in that file through time or when that file is an important piece of the analysis that would be required for a peer to recreate your work. As usual, git status is a good place to start and allows us to verify which files can be added/staged.\n\n$ git status\nOn branch {main}\n\nNo commits yet\n\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n        .gitignore\n        fib_seq.R\n        git_practice.Rproj\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\nWe can then use git add to stage each file one at a time. Notice that I made a typo while attempting to add the git_practice.Rproj file. I survived this catastrophe with a warning, which is typical of mistakes in the terminal.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git add .gitignore\n\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git add fib_seq.R\n\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git_add git_practice.Rproj\nbash: git_add: command not found\n\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git add git_practice.Rproj\n\nA second call to git status allows us to verify all files are staged.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git status\nOn branch {main}\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached &lt;file&gt;...\" to unstage)\n        new file:   .gitignore\n        new file:   fib_seq.R\n        new file:   git_practice.Rproj\n\nUse of git add stages files you would like to track in your git repository. The rectangle in Figure 2.2 is now filled which indicates that files within your working directory are staged and ready to be committed.\n\n\n\n\n\nFigure 2.2: The Git workspace after you have staged files in your working directory which you intend to add to your local repository.\n\n\n\n\nNotice Git tells you how to unstage a file if you added one inadvertently. On occasion there are files in your working directory which you do not want Git to track. Examples might be .pdf files for literature you referenced while conducting the analysis, word documents you produced for operational planning and reporting, or extremely large outputs. It’s fine to exclude these sort of files but before you do so consider… “Would a future researcher need access to this file to recreate my work?”. If they would you should track them in the repository.\nIt can be cumbersome to have a long list of files which Git recognizes as present in your working directory but you are not actively tracking. The solution is to open the file .gitignore and include the names of the files you do not want to track. You can use wildcards if you prefer not to track all files of a certain type and/or specify folders if you don’t want to track anything in certain sub-directories. For example, *.xlsx would ignore all .xlsx files in your working directory while posts/ would ignore all of the files in the folder posts within your working directory.\n\n\n2.0.3 git commit\nIn the git status response above 3 files were staged. Let’s commit those files in the terminal. When you make a commit you are asking Git to keep a copy of your staged files at that particular point in time. In the terminal session below we use git status to verify all of the files we want to commit are staged.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git status\nOn branch {main}\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached &lt;file&gt;...\" to unstage)\n        new file:   .gitignore\n        new file:   fib_seq.R\n        new file:   git_practice.Rproj\n\nThe command git commit is then run, with the option -m included to specify the commit message. Notice the -m option is specified twice. The first time -m is specified Git knows the text string following is the commit title. The second time -m is specified Git knows the text string following is the commit description. Commit titles are required while commit descriptions are highly encouraged. A good practice is for the title to be brief (less that 50 characters) so that it displays well in most formats. There is no length limit for the description and this is the place to provide some explanation beyond what you can capture in the title. I’ve purposely been verbose with the commit above to demonstrate a long description. Please avoid non-informative commit messages and avoid the tendency to fatigue and include less and less informative messages as the analysis proceeds.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git commit -m \"Initialize Fibonacci sequence\" -m \"Sequential additions to the Fibonacci sequence will provide a simple way to demonstrate several cycles of the git workflow including add/commit, push/pull, collaborate, fork, branch, merge, merge conflicts, exc. I even got my wife a GitHub account for this. Wish us luck!\"\n[{main} e17181f] Initialize Fibonacci sequence\n Date: Sun Jul 2 12:59:06 2023 -0800\n 3 files changed, 21 insertions(+)\n create mode 100644 .gitignore\n create mode 100644 fib_seq.R\n create mode 100644 git_practice.Rproj\n\nThe git status output after the commit shows that all of the files in the working directory are included in the repository in their current state.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git status\nOn branch {main}\nnothing to commit, working tree clean\n\nThe git log command provides a summary of the commit. Two important parts are the commit ID and the commit message. The commit ID is a code which can be used to reference the commit in the future. Git assigned a long ID to each commit (e17181fa781b2e30096e1c7d31443aac18d527e5 for this commit) but its common to using only the first 7 characters of the commit ID (e17181f) to refer to the commit.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git log\ncommit e17181fa781b2e30096e1c7d31443aac18d527e5 (HEAD -&gt; {main})\nAuthor: Adam Reimer &lt;adam.reimer@alaska.gov&gt;\nDate:   Sun Jul 2 12:59:06 2023 -0800\n\n    Initialize Fibonacci sequence\n\n    Sequential additions to the Fibonacci sequence will provide a simple way to demonstrate several cycles of the git workflow including add/commit, push/pull, collaborate, fork, branch, merge, merge conflicts, exc. I even got my wife a GitHub account for this. Wish us luck!\n\nUse of git commit includes the files you would like to track in your git repository. The working directory in Figure 2.3 now shows an empty rectangle (as the files are no longer staged) but also includes a entry in the local repository identified with a short ID.\n\n\n\n\n\nFigure 2.3: The Git workspace after you have committed your staged files to your local repository.\n\n\n\n\nThe git workflow described so far forms the basis on reproducible research using Git. We will calculate the next several values in the Fibonacci sequence to practice this workflow. The same sequence described above is repeated:\n\nA change is made to fib_seq.R (in this case a new line fib_seq[3] &lt;- fib_seq[1] + fib_seq[2] is added) and saved to the working directory. The working directory now represents a more recent snapshot of time that the local repository.\nThe changed file is staged.\nThe staged file is committed.\nRepeat steps 1 through 3.\n\nThe process looks like:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.0.3.1 When to Commit?\nSaves and a commits serve different purposes. As we all know, save can and should be used frequently… many times an hour and/or any time you are stepping away from your work. This use is agnostic to whether the analyst is or is not using a git workflow.\nIn contrast, commits are made for two reasons. First, a commit should be made whenever the analysis is at a point which you may want to revisit. Examples include: adding new data, adding a new feature to the analysis, or any time the code was run and the results were distributed. Any one of these tasks may have resulted in a new ‘version’ in the traditional workflow but they don’t have to be major updates. A second reason to commit is when the changes are substantive enough that the line-by-line change may be difficult to track if you did not commit until the new data/features are complete. These commits snapshot significant steps in a new feature’s development or prior to experimenting with a new feature.\nThe most important thing to note regarding commits is that, unlike save, there is no temporal component. While saves are designed to minimize the risk of lost work and should be frequent in time, commits are designed to record importance stages of the analysis and should be frequent with respect to progress. A difficult feature may take days to code but represent a single commit, provided the actual changes to the code are modest. Efficiency in commit frequency will pay off when the repository is being revisited at a later date and each commit is a snapshot of the analysis that is important or informative to the reviewer. Note that the commits demonstrated in this text are purposely pedantic but a good rule of thumb is that if you can’t describe why you are committing your files it may be an unnecessary commit.\n\n\n\n2.0.4 git log\nTo view our commit history in the terminal use git log. Note that the commit ID, author, date, commit title and commit description are all shown in the log. Note on large projects calling git log can result in a substantial amount out output which can be difficult to exit (type q at any time and you will exit)1.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git log\ncommit 11cf98ff67b8ec4f8cd7f2c1650a176d5875fdcf (HEAD -&gt; {main})\nAuthor: Adam Reimer &lt;adam.reimer@alaska.gov&gt;\nDate:   Sun Jul 2 14:53:05 2023 -0800\n\n    Fourth entry in the Fibonacci sequence\n\n    Long and informative message goes here.\n\ncommit 3bb6c98bb0048bad7bda489bd8d40be24fb66acf\nAuthor: Adam Reimer &lt;adam.reimer@alaska.gov&gt;\nDate:   Sun Jul 2 14:31:04 2023 -0800\n\n    Third entry in fib_seq\n\n    This message is not necessary for such a simple commit, but descriptions are an important part of reproducible research I’m writing a long message to set a good example.  Have better content in yours.\n\ncommit e17181fa781b2e30096e1c7d31443aac18d527e5\nAuthor: Adam Reimer &lt;adam.reimer@alaska.gov&gt;\nDate:   Sun Jul 2 12:59:06 2023 -0800\n\n    Initialize Fibonacci sequence\n\n    Sequential additions to the Fibonacci sequence will provide a simple way to demonstrate several cycles of the git workflow including add/commit, push/pull, collaborate, fork, branch, merge, merge conflicts, exc. I even got my wife a GitHub account\nfor this. Wish us luck!\n\n\n\n2.0.5 git diff\nTo see the difference between two commits use git diff. With no additional arguments git diff will show the changes in the working directory relative to the last commit. Our working directory has no changes as illustrated by git status.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git status\nOn branch {main}\nnothing to commit, working tree clean\n\nIf we add a commit ID to the git diff command the output will show how the tracked files have changed relative to the point in time when commit 3bb6c9 was made.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git diff 3bb6c9\ndiff --git a/fib_seq.R b/fib_seq.R\nindex 9c118d5..4ce1d70 100644\n--- a/fib_seq.R\n+++ b/fib_seq.R\n@@ -2,4 +2,5 @@\n #Adam Reimer\n\n fib_seq &lt;- c(0, 1)\n-fib_seq[3] &lt;- fib_seq[1] + fib_seq[2]\n\\ No newline at end of file\n+fib_seq[3] &lt;- fib_seq[1] + fib_seq[2]\n+fib_seq[4] &lt;- fib_seq[2] + fib_seq[3]\n\\ No newline at end of file\n\nGit GUI’s are superior to the terminal when looking at line-by line differences but for completeness we will discuss how to read the output. The section --- a/fib_seq.R to +++ b/fib_seq.R identifies the files that were modified where --- a/ and +++ b refer to the previous and the current versions of the file respectively. The line @@ -2,4 +2,5 @@ tells us that the output is showing the original file starting on the second line and displaying the the next 4 lines (three unmarked lines and the line with a negative symbol) while the new version of the file is also shown starting from the second line but displaying the next 5 lines (the three unmarked lines and the two lines with an addition symbol). This makes sense because a single line was added to the new version.\n\n\n\n\n\n\nLater we will learn some tricks to compress the output of git log within the terminal although generally GUIs displays repository history better than the terminal and are much more commonly used.↩︎"
  },
  {
    "objectID": "collaboration.html",
    "href": "collaboration.html",
    "title": "3  Collaboration Using Git",
    "section": "",
    "text": "Git has some amazing reproducible research capabilities that can become really powerful in large complicated analyses. That said, utilizing Git comes with an overhead that may not be justified for small projects unless you consider collaboration with future analysts including yourself. To demonstrate Git’s collaborative potential I created a remote repository on GitHub called git_practice.\n\n3.0.1 Interacting with your Remote Repository\n\n3.0.1.1 git push\nTo link your local repository to a remote repository use git remote. In the terminal session below I added a remote repository named “origin” and provided a URL where the repository is located.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice ({main})\n$ git remote add origin https://github.com/adamreimer/git_practice.git\n\nThen git push is used to “push” my local repository to my remote repository. Files associated with this repository are now stored in a location where they can be accessed by others for viewing, download, or used for collaborative work.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git push -u origin main\nEnumerating objects: 11, done.\nCounting objects: 100% (11/11), done.\nDelta compression using up to 16 threads\nCompressing objects: 100% (10/10), done.\nWriting objects: 100% (11/11), 1.53 KiB | 8.00 KiB/s, done.\nTotal 11 (delta 2), reused 0 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (2/2), done.\nTo https://github.com/adamreimer/git_practice.git\n * [new branch]      main -&gt; main\nbranch 'main' set up to track 'origin/main'.\n\nAfter pushing to github your repository now looks like Figure 3.1.\n\n\n\n\n\nFigure 3.1: The Git workspace after your local repository has been pushed to a remote repository.\n\n\n\n\nNow that we have a remote repository updated we have to worry about keeping them both synced. To illustrate this workflow I’ll change the fib_seq.r file by adding the fifth value to the Fibonacci sequence (fib_seq[5] &lt;- fib_seq[3] + fib_seq[4]) as a new line. After this change the git work space will contain an unstaged change which is not reflected in either repository.\n\n\n\n\n\nFigure 3.2: The Git workspace after the working directory has been changed leaving the local and remote repositories out-of-date.\n\n\n\n\nIn the terminal session below I stage the file fib_seq.R and commit the file. Notice that after a git status command we were told the local and remote repositories were synced but that there were unstaged changes.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n        modified:   fib_seq.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nAfter the modified file was added,\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git add fib_seq.R\n\nand committed,\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git commit -m \"Fifth entry in the Fibonacci sequence\" -m \"A long and descriptive description\"\n[main 5139049] Fifth entry in the Fibonacci sequence\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\nthe second call to git status tells us our remote repository is one commit behind our local repository.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git status\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nnothing to commit, working tree clean\n\nThe git work space at this moment is illustrated by Figure 3.3.\n\n\n\n\n\nFigure 3.3: The Git workspace after a local change has been staged & committed leaving the remote repositories one commit behind.\n\n\n\n\nIn the terminal session below I use git push to update the remote repository.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git push\nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 16 threads\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 414 bytes | 8.00 KiB/s, done.\nTotal 3 (delta 1), reused 0 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (1/1), completed with 1 local object.\nTo https://github.com/adamreimer/git_practice.git\n   0c92881..5139049  main -&gt; main\n\nNotice git status verifies the repositories are now synced.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\n\nThe git work space at this moment is illustrated by Figure 3.4.\n\n\n\n\n\nFigure 3.4: The Git workspace after a local change has been staged, committed, and pushed.\n\n\n\n\n\n\n3.0.1.2 git clone\nImagine a situation where you would like to work on your analysis from a home computer1. If your analysis is stored as a remote git repository it is easy to obtain a copy. In the terminal sequence I will obtain a copy of my repository in a new location (Note in the previous file paths I have been working on a network S drive). The first step is to switch switched to my computer’s C drive.\n\namreimer@DFGSXQDSF223076 MINGW64 ~/Documents\n$ cd C:/\n\nThe command git clone copies (clones) the remote repository to my C drive.\n\namreimer@DFGSXQDSF223076 MINGW64 /c\n$ git clone https://github.com/adamreimer/git_practice.git\nCloning into 'git_practice'...\nremote: Enumerating objects: 14, done.\nremote: Counting objects: 100% (14/14), done.\nremote: Compressing objects: 100% (10/10), done.\nremote: Total 14 (delta 3), reused 14 (delta 3), pack-reused 0\nReceiving objects: 100% (14/14), done.\nResolving deltas: 100% (3/3), done.\n\nAfter which I can navigate to the new local repository,\n\namreimer@DFGSXQDSF223076 MINGW64 /c\n$ cd C:/git_practice\n\nand check the repository status. Notice that I made a typo on the git status command the first time and nothing terrible happened.\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git_status\nbash: git_status: command not found\n\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\n\nAfter git clone-ing my remote repository to my C drive I have two local repositories associated with the same remote (see Figure 3.5).\n\n\n\n\n\nFigure 3.5: The Git workspace when you have two local repositories associated with the same remote.\n\n\n\n\nIf I change the file fib_seq.R in the working directory of my C drive by adding a new line (fib_seq[6] &lt;- fib_seq[4] + fib_seq[5]), stage and commit those changes, and push local repository on my C drive to the remote repository the local repository on my S drive to be behind one commit. The terminal session below demonstrates these commands (all of which we have seen before) and the current state of the Git work space is shown in Figure 3.6.\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n        modified:   fib_seq.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git add fib_seq.R\n\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git commit -m \"Sixth number in the Fibonacci seqence\" -m \"This commit is slightly different as it was made from a different computer in my house. It still represents a single author working on their own repository but demonstrated the flexibility accorded by storing your analysis on the cloud. Working on this analysis from a new machine was seamless provided the new machine had the appropriate software.\"\n[main 9db5478] Sixth number in the Fibonacci seqence\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git status\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nnothing to commit, working tree clean\n\n\namreimer@DFGSXQDSF223076 MINGW64 /c/git_practice (main)\n$ git push\nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 16 threads\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 586 bytes | 586.00 KiB/s, done.\nTotal 3 (delta 1), reused 0 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (1/1), completed with 1 local object.\nTo https://github.com/adamreimer/git_practice.git\n   5139049..9db5478  main -&gt; main\n\n\n\n\n\n\nFigure 3.6: The Git workspace when you have one local repository has pushed a new commit to the remote repository.\n\n\n\n\n\n\n3.0.1.3 git pull\nAs Figure 3.6 demonstrates the local repository on my S drive is now one commit behind the remote (and the local repository on my C drive). In the terminal session below we try git status but are told the local and remote repositories are synced, which we know to be false.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\n\nGit has lost track of the remote since the repository on the S drive was blind to the last commit. Instead we use git update to update the remote connection, after which git status works as before.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git remote update\nremote: Enumerating objects: 5, done.\nremote: Counting objects: 100% (5/5), done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0\nUnpacking objects: 100% (3/3), 566 bytes | 0 bytes/s, done.\nFrom https://github.com/adamreimer/git_practice\n   5139049..9db5478  main       -&gt; origin/main\n\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git status\nOn branch main\nYour branch is behind 'origin/main' by 1 commit, and can be fast-forwarded.\n  (use \"git pull\" to update your local branch)\n\nnothing to commit, working tree clean\n\nFinally, git pull brings the local repository on the S drive into sync with the remote (and the local repository on my C drive). At this point the local and remote repositories have the structure of Figure 3.5 but will include an additional commit (9db5478) not shown in Figure 3.5.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git pull\nUpdating 5139049..9db5478\nFast-forward\n fib_seq.R | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git status\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\n\n\n\n\n3.0.2 Interacting with a Peer’s Remote Repository\nHow you interact with a peers remote repository depends on your goals. We will discuss three typical use cases below.\n\n3.0.2.1 git clone - To Copy/Modify Code\nImagine a situation where a peer has written some code which you would like to modify for a similar project2. Use git clone as described above. You will be able to create a copy of their repository and work on your local machine as usual, but you will not be able to push changes back to the remote.\n\n\n3.0.2.2 git clone, git push, git pull - To Collaborate (closely)\nIf you and a peer are working closely on an analysis it may be appropriate for the owner to add their peer as a collaborator to the project. This is a point-and-click task from your github repository page, Settings&gt;Collaborators&gt;Add people&gt;(keypunch the username). The collaborator can push and pull changes to the remote as if they were the owner. This arrangement is only appropriate for peers who you trust to commit changes of which you both approve. In practice, this likely means there will be personal communication to coordinate each person’s efforts. To demonstrate this process I added my wife (Carly) as a collaborator to the git_practice repository. Carly then cloned the repository, modified the fib_seq.R file by adding a new line (fib_seq[7] &lt;- fib_seq[5] + fib_seq[6]), staged the file, committed the changes, and pushed her local repository back to the git_practice remote. Afterwards I pulled those changes back to the local repository on my S drive. The terminal session and figures associated with these actions would closely mirror those shown for git clone, git push, and git pull above although the local repositories have different owners in this case. To demonstrate commits were made by both collaborators I ran a specially formatted call3 to git log which shows that the latest commit to this repository did come form a new author.\n\namreimer@DFGSXQDSF223076 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git log --pretty=format:\"%h%x09%an%x09%ad%x09%s\"\nf732cdb Carly Reimer    Sun Jul 2 22:01:17 2023 -0800   Seventh Fibonacci number\n9db5478 Adam Reimer     Sun Jul 2 20:39:19 2023 -0800   Sixth number in the Fibonacci seqence\n5139049 Adam Reimer     Sun Jul 2 16:15:52 2023 -0800   Fifth entry in the Fibonacci sequence\n0c92881 Adam Reimer     Sun Jul 2 14:53:05 2023 -0800   Fourth entry in the Fibonacci sequence\n3bb6c98 Adam Reimer     Sun Jul 2 14:31:04 2023 -0800   Third entry in fib_seq\ne17181f Adam Reimer     Sun Jul 2 12:59:06 2023 -0800   Initialize Fibonacci sequence\n\n\n\n3.0.2.3 fork - To Collaborate (formally)\nFork is a GitHub operation which creates a copy of another user’s remote repository under your GitHub ID. After the fork is created you can clone it to a local repository as described above. Your local repository can be configured to sync with the original (upstream) repository so that your local repository can track changes the original author made after fork. If you make significant changes to the repository that the original author may be interested in you can submit a pull request which notifies the original author about the changes you have made and gives them the opportunity to include your code in the repository. Github has great documentation of this process.\nAs an example I revoked my wife’s collaborator status on the git_practice repository associated with my GitHub account. Carly then forked the git_practice repository in my account. Afterwards, the forked version of the git_practice repository in her account looked something like this:\n\n\n\nThe forked git_practice repository in Carly Reimer’s GitHub account\n\n\nUsing the same commands described above, Carly cloned the forked repository, made changes, added the changed file, committed the changes, and pushed the result back to her forked repository on Github. Pull requests are so named because Carly is asking me to pull her forked repository back into my original repository. To initiate a pull request the owner of the forked repository (Carly) navigates to the original repository and presses the Pull request button. The pull request looked like this when viewed from my account:\n\n\n\nThe pull request summary screen.\n\n\nNavigating the the Files changed button allows the repository owner to review line by line changes associated with the pull request. In this case, I deemed the suggestions reasonable and accepted them without comment but there are capabilities to comments and modify the changes before they are accepted.\n\n\n\nThe pull request review/approval screen\n\n\nAfter the request is approved the original owner can merge the pull request from within GitHub.\n\n\n\nMerging a pull request\n\n\nAfter merging the pull request; Carly’s local repository, the forked repository, and the original remote repository are synced while Adam’s local repository is behind. This situation could be fixed with git pull.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git pull\nremote: Enumerating objects: 12, done.\nremote: Counting objects: 100% (12/12), done.\nremote: Compressing objects: 100% (7/7), done.\nremote: Total 10 (delta 3), reused 9 (delta 3), pack-reused 0\nUnpacking objects: 100% (10/10), 2.60 KiB | 1024 bytes/s, done.\nFrom https://github.com/adamreimer/git_practice\n   f732cdb..22dcfea  main       -&gt; origin/main\nUpdating f732cdb..22dcfea\nFast-forward\n fib_seq.R | 8 ++++++--\n 1 file changed, 6 insertions(+), 2 deletions(-)\n\n\n\n\n\n\n\n\nI hope your analysis is on the network and you could use vpn to solve this problem.↩︎\nCommon courtesy requires you to ask permission and credit the person who originally wrote the code.↩︎\nThanks Jesper Rønn-Jensen! Note: %h specifies the short commit ID, %x09 specifies a tab, %an specifies the author, %ad specifies the commit date, and %s specifies the commit title.↩︎"
  },
  {
    "objectID": "branch.html",
    "href": "branch.html",
    "title": "4  Branching and Model Development",
    "section": "",
    "text": "The intermediate Git workflow introduces a new concept: branches. Efficient use of branches and a well thought out branching strategy will aid the analyst in Git use and is also a powerful tool for model development.\n\n4.0.1 Branches and Branch strategy\nIn Git a branch is a pointer to a specific commit or set of commits which allow you to separate model development tasks into smaller subunits. I learned branching from this guy and in what follows I simplify his workflow into something that works well for complicated fisheries analyses. Let’s start by creating a new branch named develop using the command git checkout. The argument -b tells Git to checkout a new branch while the arguments develop and main tell Git the name of the new branch and that the new branch should branch from the main branch.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git checkout -b develop main\nSwitched to a new branch 'develop'\n\nThe core concept in the Git Flow branching strategy is to always have two active branches; main and develop. The main branch is stable in that you make limited commits to it and those commits are associated with internal or external reporting including FDS reports, BOF memos, or conference presentations. Because the main branch will largely be static interested collaborators can quickly identify the analysis at the time periods where the analysis was reported.\nThe develop branch is the working branch and will have frequent commits relative to analysis progress. The develop branch merges into main at reporting periods and is the one branched from whenever a new feature is being developed.\nFeature branches are created frequently as new features are envisioned and developed. A best practice is to create a new feature branch, with a descriptive name, every time you create a new feature. When the feature is completed it is merged back into develop, left as a record without a merge, or deleted. In my work, feature branches are mostly merged back into develop, and this occurs whenever I create a feature which improves the analysis. Feature branches are left unmerged when I want to retain a record of having tried something (and the result) but do not think it improves the overall analysis. Feature branches are deleted without merging when something just did not work out and is also not worth retaining as a record. Notice that liberal use of feature branches keep the main and develop branches clean and can isolate those two primary branches of a lot of the sloppiness that is a byproduct of actively engaging in the scientific process.\nLet’s practice Git Flow. In the terminal session which follows we create a new branch called cleanup with git checkout. On the new branch we modify modify the file fib_seq.R by deleting several lines of manual Fibonacci sequence calculations and replacing them with a for loop.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git checkout -b cleanup develop\nSwitched to a new branch 'cleanup'\n\nCalling git status shows that the cleanup branch now contains upstaged changes.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (cleanup)\n$ git status\nOn branch cleanup\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n        modified:   fib_seq.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nWe can view those changes using git diff.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (cleanup)\n$ git diff\ndiff --git a/fib_seq.R b/fib_seq.R\nindex 984a0a5..97be5b3 100644\n--- a/fib_seq.R\n+++ b/fib_seq.R\n@@ -2,12 +2,7 @@\n #Adam Reimer & Carly Reimer\n\n fib_seq &lt;- c(0, 1)\n-fib_seq[3] &lt;- fib_seq[1] + fib_seq[2]\n-fib_seq[4] &lt;- fib_seq[2] + fib_seq[3]\n-fib_seq[5] &lt;- fib_seq[3] + fib_seq[4]\n-fib_seq[6] &lt;- fib_seq[4] + fib_seq[5]\n-fib_seq[7] &lt;- fib_seq[5] + fib_seq[6]\n-for (i in 8:51) fib_seq[i] &lt;- sum(fib_seq[(i-1):(i-2)])\n+for (i in 3:51) fib_seq[i] &lt;- sum(fib_seq[(i-1):(i-2)])\n\n plot(1:50, fib_seq[2:51]/fib_seq[1:50], type = \"l\")\n-{golden_ration &lt;- fib_seq[51]/fib_seq[50]}\n+{golden_ratio &lt;- fib_seq[51]/fib_seq[50]}\n\nAnd then add and commit the change.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (cleanup)\n$ git add fib_seq.R\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (cleanup)\n$ git commit -m \"remove maanual Fibonacci calculations\" -m \"manual calculations become redundent now that we are using recurstion to get the series.\"\n[cleanup 8b28369] remove maanual Fibonacci calculations\n 1 file changed, 2 insertions(+), 7 deletions(-)\n\n\n\n4.0.2 git merge\nThe changes above are reasonable and the new feature tried on the cleanup branch is useful. In the terminal session below we use git checkout to switch back to the develop branch,\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (cleanup)\n$ git checkout develop\nSwitched to branch 'develop'\n\ngit merge to merge the cleanup branch with the develop branch,\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git merge --no-ff cleanup\nMerge made by the 'ort' strategy.\n fib_seq.R | 9 ++-------\n 1 file changed, 2 insertions(+), 7 deletions(-)\n\nand git branch to delete the cleanup branch now that its change has been incorporated into develop.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git branch -d cleanup\nDeleted branch cleanup (was 8b28369).\n\n\n4.0.2.1 Merge conflicts\nMerge conflicts can occur any time we are merging two branches. In what follows we will intentionally create a merge conflict and fix it. In the terminal session below I create a new branch named label_plot, and while working on that branch modify the file fib_seq.R by adding informative figure labels and then stage/commit those changes.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git checkout -b label_plot develop\nSwitched to a new branch 'label_plot'\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (label_plot)\n$ git status\nOn branch label_plot\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n        modified:   fib_seq.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (label_plot)\n$ git add fib_seq.R\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (label_plot)\n$ git commit -m \"Added axis labels to golden ratio plot.\" -m \"Not a lot to say but hammering home the idea that more informative messages are better. In this case I added labels to demonstrate a merge conflict. Will add different labels to the same file/figure on branch develop to create the conflict.\"\n[label_plot a4c0f61] Added axis labels to golden ratio plot.\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\nA merge into the develop branch at this stage would be both appropriate and successful. The new feature was added to the feature branch label_plot was a improvement, and the develop branch is unchanged. Instead we will intentionally change the develop branch (violating the spirit of Git Flow) to demonstrate a merge conflict. In the terminal session that follows we: checkout the develop branch and while working on that branch modified the file fib_seq.R by adding less informative figure labels, and stage/commit those changes.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (label_plot)\n$ git checkout develop\nSwitched to branch 'develop'\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git status\nOn branch develop\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n        modified:   fib_seq.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git add fib_seq.R\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git commit -m \"Added labels to the golden ratio figure\" -m \"These labels are intentionally less informative that the labels added on the feature branch to demonstrate that feature branches are where you do the work which you then merge into develop.\"\n[develop d0d260e] Added labels to the golden ratio figure\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\nWe then use git show to look at the copy of fib_seq.R from both the develop and label_plot branches. Notice that the axis labels from the label_plot branch are more informative. Because the values given to the xlab and ylab arguments were modified in both branches we can expect a merge conflict.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git show develop:fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq &lt;- c(0, 1)\nfor (i in 3:51) fib_seq[i] &lt;- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Number\",\n     ylab = \"Ratio\")\n{golden_ratio &lt;- fib_seq[51]/fib_seq[50]}\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git show label_plot:fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq &lt;- c(0, 1)\nfor (i in 3:51) fib_seq[i] &lt;- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Fibonacci Number in Denominator\",\n     ylab = \"Ratio Between Succesive Fibonacci Numbers\")\n{golden_ratio &lt;- fib_seq[51]/fib_seq[50]}\n\nAs expected, a merge conflict results from attempting to merge these branches.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git merge --no-ff label_plot\nAuto-merging fib_seq.R\nCONFLICT (content): Merge conflict in fib_seq.R\nAutomatic merge failed; fix conflicts and then commit the result.\n\nWhen there is a merge conflict Git modifies the file being merged to help the user decide how to proceed. Git adds &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD above the merge conflict. The text ====== separates the merge conflict into code derived from each branch. Code between &lt;&lt;&lt;&lt;&lt;&lt; HEAD and ====== indicates code which was present in the branch being merged into (develop in this case) while code between ====== and &gt;&gt;&gt;&gt;&gt;&gt; label_plot indicates code which was present in the branch being merged (label_plot in this case). I’ve shown what that fib_seq.R file in my working directory looks like using the terminal command cat, but that is only for demonstrative purposes. Normally, I would just open the file in RStudio, and it would look exactly the same. To proceed the user has to decide which code to keep, save the modified file, and stage/commit the changes. For this example I deleted everything between &lt;&lt;&lt;&lt;&lt;&lt; HEAD and ====== inclusive as well as the line &gt;&gt;&gt;&gt;&gt;&gt; label_plot. These deletions modified the file fib_seq.R to represent the version we wish to retain.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop|MERGING)\n$ cat fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq &lt;- c(0, 1)\nfor (i in 3:51) fib_seq[i] &lt;- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n     type = \"l\",\n     xlab = \"Number\",\n     ylab = \"Ratio\")\n======\n     type = \"l\",\n     xlab = \"Fibonacci Number in Denominator\",\n     ylab = \"Ratio Between Succesive Fibonacci Numbers\")\n&gt;&gt;&gt;&gt;&gt;&gt; label_plot\n{golden_ratio &lt;- fib_seq[51]/fib_seq[50]}\n\nNotice that git status knows we need to fix this merge conflict and tells us how to do it.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop|MERGING)\n$ git status\nOn branch develop\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n  (use \"git add &lt;file&gt;...\" to mark resolution)\n        both modified:   fib_seq.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop|MERGING)\n$ git add fib_seq.R\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop|MERGING)\n$ git commit -m \"fixed merge conflict by accepting changes from label_plot branch\" -m \"Mmaybe the only good example of a situation were a description is not nessesary.\"\n[develop ad2149a] fixed merge conflict by accepting changes from label_plot branch\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git status\nOn branch develop\nnothing to commit, working tree clean\n\n\n\n\n4.0.3"
  },
  {
    "objectID": "history.html",
    "href": "history.html",
    "title": "5  Interacting with your Git history",
    "section": "",
    "text": "5.0.1 Restoring a previous version of a file\nYou can also use git checkout to recall a single file from a previous commit. In the terminal sequence below I use cat to show that the file in my work directory.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ cat fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq &lt;- c(0, 1)\nfor (i in 3:51) fib_seq[i] &lt;- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Fibonacci Number in Denominator\",\n     ylab = \"Ratio Between Succesive Fibonacci Numbers\")\n{golden_ratio &lt;- fib_seq[51]/fib_seq[50]}\n\nWe can compare that to the file in the most recent commit in the develop branch using git show. They are the same file.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git show develop:fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq &lt;- c(0, 1)\nfor (i in 3:51) fib_seq[i] &lt;- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Fibonacci Number in Denominator\",\n     ylab = \"Ratio Between Succesive Fibonacci Numbers\")\n{golden_ratio &lt;- fib_seq[51]/fib_seq[50]}\n\nNotice a call to git status reports the same thing without showing the files explicitly.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git status\nOn branch develop\nnothing to commit, working tree clean\n\nTo retrieve a specific file from a prior commit you have to provide git checkout with identifying information for the commit and the file name. You can specify the appropriate commit with a absolute or relative reference. For an absolute reference provide the SHA #. For a relative reference the shorthand is HEAD~# where # is the number of commits prior to the latest commit. In the terminal sequence below I used checkout to retrieve a copy of fib_seq.R from 1 commit earlier (recall this commit had the less informative x and y axis labels).\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git checkout HEAD~1 fib_seq.R\nUpdated 1 path from abb8fba\n\nNotice the earlier version of fib_seq.R is now present in my working directory (as shown in the output for cat), but was not included in the latest commit to my repository (as shown in the output to git show). Also note that `git status is aware of the change.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ cat fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq &lt;- c(0, 1)\nfor (i in 3:51) fib_seq[i] &lt;- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Number\",\n     ylab = \"Ratio\")\n{golden_ratio &lt;- fib_seq[51]/fib_seq[50]}\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git show develop:fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq &lt;- c(0, 1)\nfor (i in 3:51) fib_seq[i] &lt;- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Fibonacci Number in Denominator\",\n     ylab = \"Ratio Between Succesive Fibonacci Numbers\")\n{golden_ratio &lt;- fib_seq[51]/fib_seq[50]}\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git status\nOn branch develop\nChanges to be committed:\n  (use \"git restore --staged &lt;file&gt;...\" to unstage)\n        modified:   fib_seq.R\n\nIf I wanted the earlier version of fib_seq.R to be associated with the most recent commit to my repository I would need to commit the file. In this case I did not want to change my repository so I used git checkout to go back the the most recent version (Using the relative reference HEAD to specify the latest commit). I often use this sequence to recall all or part of a code from a prior commit.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git checkout HEAD fib_seq.R\nUpdated 1 path from bd65128\n\nThis all worked, all call to cat shows that the file in my working directory has returned to the version with more informative file labels.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ cat fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq &lt;- c(0, 1)\nfor (i in 3:51) fib_seq[i] &lt;- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Fibonacci Number in Denominator\",\n     ylab = \"Ratio Between Succesive Fibonacci Numbers\")\n{golden_ratio &lt;- fib_seq[51]/fib_seq[50]}\n\n\n\n5.0.2 Retrieving a prior commit\nYet another use of git checkout is to recall a previous commit in its entirety. Since our repository only has one file, I created, staged, and committed a second file named test.R to demonstrate this functionality. In the terminal sequence below I show the contents of test.R and some now familiar content where I check the status of my repository and stage/commit the new file.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ cat test.R\n#Blank file to see if we can use git checkout to retrieve an entire commit.\n#Proof would be seeing this file and the correct version of fib_seq.R\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git status\nOn branch develop\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n        test.R\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git add test.R\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git commit -m \"Test.R file added. Used to test that git checkout recalls an entire commit\" -m \"added a second file so to verify both files come when I jump around commits.\"\n[develop 4ef90af] Test.R file added. Used to test that git checkout recalls an entire commit\n 1 file changed, 2 insertions(+)\n create mode 100644 test.R\n\nTo retrieve a prior commit you should create a new branch to house the past commit until you decide what to do with it. While not strictly necessary, creating a new branch is stable and protects your develop branch. In the terminal session below I use git checkout to create a new branch called old_state and fill it with the snapshot of the develop branch from 2 commits earlier. I am expecting old state to be missing test.R and have the less descriptive axis locations in the version of fib_seq.R.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git checkout -b old_state HEAD~2\nSwitched to a new branch 'old_state'\n\nTwo calls to cat confirm that my working directory does not contain test.R and has the older version of fib_seq.R\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (old_state)\n$ cat fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq &lt;- c(0, 1)\nfor (i in 3:51) fib_seq[i] &lt;- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Number\",\n     ylab = \"Ratio\")\n{golden_ratio &lt;- fib_seq[51]/fib_seq[50]}\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (old_state)\n$ cat test.R\ncat: test.R: No such file or directory\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (old_state)\n$ git status\nOn branch old_state\nnothing to commit, working tree clean\n\nThe next action depends on if you want the keep working on the prior commit. If you do you can modify files and stage/commit the result as appropriate prior to merging old_state back into develop. Since we purposely started the old_state feature branch from a prior version of develop the odds of a merge conflict are high. It does mean it’s a terrible idea but you should be doing this with intention. In the terminal session below I decided the prior commit was not an improvement on my original commit so I moved back to the develop branch and deleted the old_state branch. Two calls to cat proved that the original files were returned.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (old_state)\n$ git checkout develop\nSwitched to branch 'develop'\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ cat fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq &lt;- c(0, 1)\nfor (i in 3:51) fib_seq[i] &lt;- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Fibonacci Number in Denominator\",\n     ylab = \"Ratio Between Succesive Fibonacci Numbers\")\n{golden_ratio &lt;- fib_seq[51]/fib_seq[50]}\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ cat test.R\n#Blank file to see if we can use git checkout to retrieve an entire commit.\n#Proof would be seeing this file and the correct version of fib_seq.R\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git branch -d old_state\nDeleted branch old_state (was d0d260e).\n\n\n\n5.0.3 Deleting/Reversing a commit\nThere are two ways to reverse a commit. The version you should choose depends on if you have pushed the commit to a remote repository.\n\n5.0.3.1 Deleting a local commit\nWhen the bad commit is local you can us git reset to delete the commit. The commit will disappear from your history. To demonstrate this command I modified the fib_seq.R by adding an inconsequential comment at the bottom of the file and used the cat command to show the file.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ cat fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq &lt;- c(0, 1)\nfor (i in 3:51) fib_seq[i] &lt;- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Fibonacci Number in Denominator\",\n     ylab = \"Ratio Between Succesive Fibonacci Numbers\")\n{golden_ratio &lt;- fib_seq[51]/fib_seq[50]}\n\n#Useless comment to demonstrate how to delete a commit\n\nAfter adding and committing the file a call to git log shows that the commit was recorded.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git add fib_seq.R\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git commit -m \"bad commit, plan to delete\" -m \"This commit has one change, a useless comment added to the fib_seq.R file. Plan to reset the HEAD to delete the commit\"\n[develop ae2fe59] bad commit, plan to delete\n 1 file changed, 2 insertions(+)\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git log --oneline\nae2fe59 (HEAD -&gt; develop) bad commit, plan to delete\n4ef90af Test.R file added. Used to test that git checkout recalls an entire commit\nad2149a fixed merge conflict by accepting changes from label_plot branch\nd0d260e Added labels to the golden ratio figure\na4c0f61 Added axis labels to golden ratio plot.\neb216a6 Merge branch 'cleanup' into develop\n8b28369 remove maanual Fibonacci calculations\n22dcfea (origin/main, main) Merge pull request #2 from carlyreimer/main\nf811c50 Update fib_seq.R\nedbaafa Update fib_seq.R\nac48c12 Finally added a for loop and golden ratio estimate\nf732cdb Seventh Fibonacci number\n9db5478 Sixth number in the Fibonacci seqence\n5139049 Fifth entry in the Fibonacci sequence\n0c92881 Fourth entry in the Fibonacci sequence\n3bb6c98 Third entry in fib_seq\ne17181f Initialize Fibonacci sequence\n\nIn the terminal session below I use git reset to reset my local repository to 1 commit prior to the most recent commit.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git reset HEAD~1 --hard\nHEAD is now at 4ef90af Test.R file added. Used to test that git checkout recalls an entire commit\n\nNotice that the comment I added to the most recent commit is no longer a part of the fib_seq.R file.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ cat fib_seq.R\n#Create a Fibonacci sequence to practice git operations\n#Adam Reimer & Carly Reimer\n\nfib_seq &lt;- c(0, 1)\nfor (i in 3:51) fib_seq[i] &lt;- sum(fib_seq[(i-1):(i-2)])\n\nplot(1:50, fib_seq[2:51]/fib_seq[1:50],\n     type = \"l\",\n     xlab = \"Fibonacci Number in Denominator\",\n     ylab = \"Ratio Between Succesive Fibonacci Numbers\")\n{golden_ratio &lt;- fib_seq[51]/fib_seq[50]}\n\nIf we call git log again we will see that commit ae2fe59 has been removed for the repository. The important thing to note is git reset changes the repository history. If you are working locally this is OK but if you have already pushed the bad commit to a remote then deleting a part of your history will cause problems for collaborators who pulled the original history.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git log --oneline\n4ef90af (HEAD -&gt; develop) Test.R file added. Used to test that git checkout recalls an entire commit\nad2149a fixed merge conflict by accepting changes from label_plot branch\nd0d260e Added labels to the golden ratio figure\na4c0f61 Added axis labels to golden ratio plot.\neb216a6 Merge branch 'cleanup' into develop\n8b28369 remove maanual Fibonacci calculations\n22dcfea (origin/main, main) Merge pull request #2 from carlyreimer/main\nf811c50 Update fib_seq.R\nedbaafa Update fib_seq.R\nac48c12 Finally added a for loop and golden ratio estimate\nf732cdb Seventh Fibonacci number\n9db5478 Sixth number in the Fibonacci seqence\n5139049 Fifth entry in the Fibonacci sequence\n0c92881 Fourth entry in the Fibonacci sequence\n3bb6c98 Third entry in fib_seq\ne17181f Initialize Fibonacci sequence\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git status\nOn branch develop\nnothing to commit, working tree clean\n\n\n\n5.0.3.2 Reversing a local/remote commit\nBecause revising your history in a public repository is bad collaboration Git has devised a solution. The git revert command can also be used to undo a mistaken commit but it does so in a very deliberate way… by creating a new commit that exactly undoes the prior commit. This method provides a stable Git history to your collaborators. In the git session below I modified the fib_seq.R again (with an inconsequential comment) and added/committed the change. git log shows the new commit.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git status\nOn branch develop\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n        modified:   fib_seq.R\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git add fib_seq.R\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git commit -m \"bad commit, plan to revert\" -m \"This commit has one change, a useless comment added to the fib_seq.R file. Plan to revert the commit\"\"\n&gt; \"\n[develop a0c849e] bad commit, plan to revert\n 1 file changed, 2 insertions(+)\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git log --oneline\na0c849e (HEAD -&gt; develop) bad commit, plan to revert\n4ef90af Test.R file added. Used to test that git checkout recalls an entire commit\nad2149a fixed merge conflict by accepting changes from label_plot branch\nd0d260e Added labels to the golden ratio figure\na4c0f61 Added axis labels to golden ratio plot.\neb216a6 Merge branch 'cleanup' into develop\n8b28369 remove maanual Fibonacci calculations\n22dcfea (origin/main, main) Merge pull request #2 from carlyreimer/main\nf811c50 Update fib_seq.R\nedbaafa Update fib_seq.R\nac48c12 Finally added a for loop and golden ratio estimate\nf732cdb Seventh Fibonacci number\n9db5478 Sixth number in the Fibonacci seqence\n5139049 Fifth entry in the Fibonacci sequence\n0c92881 Fourth entry in the Fibonacci sequence\n3bb6c98 Third entry in fib_seq\ne17181f Initialize Fibonacci sequence\n\nUsing git revert I specify the short SHA id from the prior commit.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git revert a0c849e\n[develop 6466f85] Revert commit titled: \"bad commit, plan to revert\"\n 1 file changed, 2 deletions(-)\n\nThe call to git log shows that a new commit was added with a message specifying the commit reverted the commit titled “bad commit, plan to revert”.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git log --oneline\n6466f85 (HEAD -&gt; develop) Revert commit titled: \"bad commit, plan to revert\"\na0c849e bad commit, plan to revert\n4ef90af Test.R file added. Used to test that git checkout recalls an entire commit\nad2149a fixed merge conflict by accepting changes from label_plot branch\nd0d260e Added labels to the golden ratio figure\na4c0f61 Added axis labels to golden ratio plot.\neb216a6 Merge branch 'cleanup' into develop\n8b28369 remove maanual Fibonacci calculations\n22dcfea (origin/main, main) Merge pull request #2 from carlyreimer/main\nf811c50 Update fib_seq.R\nedbaafa Update fib_seq.R\nac48c12 Finally added a for loop and golden ratio estimate\nf732cdb Seventh Fibonacci number\n9db5478 Sixth number in the Fibonacci seqence\n5139049 Fifth entry in the Fibonacci sequence\n0c92881 Fourth entry in the Fibonacci sequence\n3bb6c98 Third entry in fib_seq\ne17181f Initialize Fibonacci sequence\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git status\nOn branch develop\nnothing to commit, working tree clean"
  },
  {
    "objectID": "laststeps.html",
    "href": "laststeps.html",
    "title": "6  Before you go!",
    "section": "",
    "text": "Like any analysis, we should tidy up before we close the git_practice repository for an extended amount of time. The repository may or may not have any enduring value but it helped me get through this book! As such the repository is about to go public. That being the case the Git Flow workflow suggests we: merge develop back into main prior to pushing our code to a remote.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git checkout main\nSwitched to branch 'main'\nYour branch is up to date with 'origin/main'.\n\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git merge --no-ff develop\nMerge made by the 'ort' strategy.\n fib_seq.R | 14 ++++++--------\n test.R    |  2 ++\n 2 files changed, 8 insertions(+), 8 deletions(-)\n create mode 100644 test.R\n\nThe current state of the repository may be of interest since it marks the end of the development we documented in this book. A convenient way to mark a particular commit as special is with git tag. In the terminal session below I add a tag the most recent commit and add a short message detailing why this commit is special.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git tag -a \"v1.1\" -m \"This tag is synchronized with the first draft of the git book.\"\n\nAfter you have created a tag it is useful to know how to reference them. A plain call to git tag will show the tags in the repository.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git tag\nv1.1\n\nYou can also use git show to reference the tag and obtain additional information about the tag and the commit it is associated with.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git show v1.1\ntag v1.1\nTagger: Adam Reimer &lt;adam.reimer@alaska.gov&gt;\nDate:   Tue Jul 11 15:14:24 2023 -0800\n\nThis tag is synchronized with the first draft of the git book.\n\ncommit ef33f10150d6248b61558f63f98bd1d5acb3d771 (HEAD -&gt; main, tag: v1.1)\nMerge: 22dcfea 6466f85\nAuthor: Adam Reimer &lt;adam.reimer@alaska.gov&gt;\nDate:   Tue Jul 11 15:08:02 2023 -0800\n\n    Merge branch 'develop'\n\n\n6.0.1 Choosing the Appropriate Remote\nThus far I had been interacting with my private remote, as shown below (notice “adamreimer” in the URL). This is the preferred workflow for a repository of this type, which had no value to other ADF&G staff while it was being created.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (develop)\n$ git remote -v\norigin  https://github.com/adamreimer/git_practice.git (fetch)\norigin  https://github.com/adamreimer/git_practice.git (push)\n\nRepositories with immediate staff interest or repositories that develop staff interest (i.e repositories associated with operational plans, any population assessment or any data analysis task which is shared internally) need to be pushed to the Division of Sport Fisheries GitHub site. There are two ways to do this, both of which will be discussed below.\n\n6.0.1.1 Push directly to the new site\nThe easiest way get your repository on the ADFG-DSF account would be push it there directly. The first step is to create a new repository named “git_practice” on the ADFG-DSF GitHub1. After that “git_practice” repository is created you can change the URL associated with your origin remote (notice “ADFG-DSF” in the URL),\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git remote set-url origin https://github.com/ADFG-DSF/git_practice.git\n\nand push to it.\n\namreimer@DFGSXQDSF206801 MINGW64 /s/RTS/Reimer/Research_Best_Practices/git_practice (main)\n$ git push -u origin main\nEnumerating objects: 49, done.\nCounting objects: 100% (49/49), done.\nDelta compression using up to 16 threads\nCompressing objects: 100% (48/48), done.\nWriting objects: 100% (49/49), 8.21 KiB | 75.00 KiB/s, done.\nTotal 49 (delta 14), reused 0 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (14/14), done.\nTo https://github.com/ADFG-DSF/git_practice.git\n * [new branch]      main -&gt; main\nbranch 'main' set up to track 'origin/main'.\n\nAfter the push the remote repository is synced with your local directory you should create a README by opening the repository on GItHub and pushing the green button add README. This method will work for any existing repository2.\n\n\n6.0.1.2 Transfer a Repository\nWhile the method above will work for any repository be aware that GitHub specific features (Issues and Pull request records) will be lost when pushed to the new remote. To illustrate that difference I transferred the “git_practice” repository from my personal account to the ADFG-DSF account: (open the repository on github), Settings &gt; (scroll to the very bottom) &gt; Transfer &gt; (rename to git_practice_transfer). We can see the difference by comparing the repository that was pushed to the ADFG-DSF account to the repository that was transferred to the ADFG-DSF account. In the transferred repository there are closed pull requests listed under pull requests while on the pushed repository those records are missing. Notice that if the repository was had peer involvement sufficient to utilize pull requests or was in a state of development that necessitated issue tracking it should have been pushed to the ADFG-DSF account earlier in it’s history.\n\n\n\n\n\n\n\nFrom the main page ADFG_DSF GitHub page: New &gt; (enter “git_practice” for the repository name), (choose public or private) -&gt; create repository.↩︎\nNote if the repository does not have an existing remote the command git remote set-url origin https://github.com/ADFG-DSF/git_practice.git would be replaced with git remote add origin https://github.com/ADFG-DSF/git_practice.git↩︎"
  },
  {
    "objectID": "RStudio.html",
    "href": "RStudio.html",
    "title": "Appendix A — The RStudio Graphical User Interface",
    "section": "",
    "text": "Congratulations! If you are reading this you have done your homework and earned the right to confidently use a graphical user interface to simplify the most common Git tasks. Using a GUI can save a lot of keystrokes for most commands. The most accessible GUI is found in RStudio itself. A Git tab will show up in the Environment/History/Connections/Tutorial window (generally the upper left hand quadrant) provided your directory is a Git repository.\n\n\n\nThe RStudio windows with the Git pane shown in the top right quadrant.\n\n\n\nA.0.1 git init\nIf you are starting a brand new analysis, creating a git repository at the same time you create your R studio project is easy: New Project&gt;New Directory&gt;New Project&gt;(provide name, location and check ‘create git repository’). This sequence runs git init in the background while the RStudio project is created.\n\n\nA.0.2 Commands accessible through the Git tab\n\ngit add - add/Stage files by clicking the radio button next to each file in the RStudio Git pane.\ngit diff- the Diff button will lead to another screen where the GUI allows users to diff and commit the repository.\ngit commit - the Commit button will lead to another screen where the GUI allows users to commit and diff the repository.\ngit pull - the Pull button allows the user to pull commits from the remote repository to the local repository.\ngit push - the Push button allows the user to push commits from the local repository to the remote repository.\ngit log - the History button will lead to another screen where the GUI allows users to log the repository.\ngit revert - the More button will allow the user to revert a commit. It also allows the user to add files to the .gitignore file by clicking the radio button next to the files you wish to ignore.\ngit checkout -b and git remote - the flowchart shaped button will allow you to create a new branch and add a remote to the repository.\ngit checkout &lt;new_branch&gt; - the drop down list next to the word “main” will allow you to switch between branches.\nNote the RStudio GUI is frequently slow to react to changes. The circular arrow refreshes the GUI. Often it will look like nothing is happening when you are clicking the radio buttons to add/stage files but clicking the refresh button will reveal the buttons were checked.\n\n\n\n\nThe RStudio Git tab\n\n\n\n\nA.0.3 Commands accessible through the Diff window\n\ngit diff - the Changes tab will show line by line changes associated with the files in the working directory relative to the most recent commit. Old lines are shown in red while new line are shown in green. In the example shown below x- and y-axis labels are added to the plot function.\ngit commit - the Changes tab also includes a commit message window and a Commit button allowing the user to commit all of the staged changes. The commit title goes on the first line of the message window, followed by a blank line. The third line and onward contain the commit description.\n\n\n\n\nThe Diff/Commit window\n\n\n\n\nA.0.4 Commands accessible through the History window\n\ngit log - the History tab will show the list of prior commits and the line by line changes associated with each file included in each commit. In the example below manual Fibonacci sequence calculations were replaced with a for loop and a typo was corrected in the word “ratio”.\ngit checkout - RStudio does not have a direct analog to using git checkout to recall a single file but the View file @SHA-short button will open a window which includes the code that was staged and committed during that SHA . It is possible to retrieve code from a previous commit in this manner using cut, paste and save point and click commands.\n\n\n\n\nThe History window\n\n\n\n\nA.0.5 Commands not accessible using the RStudio GUI\nTo my knowledge there are certain commands that are not included in RStudio GUI.\n\ngit merge two branches. Since branching and merging is a big part of using git for model development this is a major omission. The GitKraken GUI handles merges nicely.\nThe Rstudio GUI display the Git log in a much cleaner format than the terminal with the big exception that the commit description is not visible. Since the commit description is the more informative part of the commit message this can be a substantial loss for some commits. A workaround would is to run the command git show SHA-short -s –format=%B where SHA-short is the short SHA tag for the commit description you wish to see. More powerful GUI’s (for example, GitKraken) can show the entire commit description.\ngit checkout to recall a single file from a previous commit. Using the terminal is more deliberate and proably better if you want to recall all of a large file although the cut/paste workaround described above is generally sufficent if you just want t few lines of code from a previous commit.\ngit checkout to recall a prior commit to your working directory.\ngit reset to delete a local commit."
  },
  {
    "objectID": "workflow.html",
    "href": "workflow.html",
    "title": "Appendix B — Division of Sport Fisheries Workflow",
    "section": "",
    "text": "As discussed in the preface, every analysis does not need all of the tools discussed herein. That said all analyses need to be discoverable to current and future staff. Github is a tool to make that happen. In this appendix we will step through the basic requirements to make your analyses easily discoverable on GitHub.\n\nAt a minimum stage/commit/push the analysis at the point where an operational plan or report is produced or the analysis has been shared with other staff members.\n\nDecide which files from you working directory need to be tracked by Git and modify your .gitignore file accordingly. All R code and processed data should be included in the Git repository. Raw data, .docx, .xlsx, and .pdf files can be excluded at your discretion (but see below about how to make sure those files are also discoverable).\n\nCreate a new repository under the ADF&G/DSF organizational account (Alaska Department of Fish and Game, Division of Sport Fisheries (github.com)).\n\nRepositories&gt;New repository to create a new repository\n\nAdd a good description. Repository names are opaque. Use the description field to let people know what is stored here.\nYou can leave your repository as private (the default) or make it public. The terms public or private refer to users outside of our organization. All of the repositories will be visible to ADF&G staff.\nclick the add a README file button. The readme file should describe the analysis in sufficient detail that people will be able to navigate your repository with confidence. In general, we have operational plans and reports to describe methods. The README file should be more applied and include a description of the motivation behind the analysis and a general idea of your repositories file/folder structure. The README file must also include a path to the network location where your local repository is stored so that interested staff can access the files included in .gitignore.\nclick Create repository.\n\nAll analysis conducted for ADF&G DSF should be pushed this account. To do so you will need a personal Github account. You can push to your personal account at your discretion but you mush push to the ADF&G account. Pushing to both your personal account and to our organizational account requires you to create two remotes, push to both and track changes across two remotes. It is likely this will lead to errors and omissions. For this reason a best practice would be to push to the ADF&G account only1.\n\nNavigate to the new repository and click the settings icon (a gear symbol) in the About section.\n\nAdd some topics that describe your repository. This will help people find your repository in the future. You can add any topic you want but you must include the following:\n\nGeographic area: Region I, Region II, Region 3, Statewide. Refine the geographic area if possible. For example, provide the name of the river, lake, bay or inlet as an additional topic.\nSpecies: Add the species or species group. Use the common name (e.g. ‘king-salmon’ or ‘halibut’) or or the name of a species group or complex (e.g. ‘all-species’, ‘rockfish’, or ‘salmon’).\nResearch type: examples include, ‘creel’, ‘mark-recapture’, ‘escapement goal’, etc.\n\n\nPush your local repository to the newly created remote.\n\nNavigate to the new repository and click Code.\nCopy the https address there and use it to add/modify a remote in your local repository.\nPush to the remote repository.\n\nKeep your network drive current with whatever changes you make on the remote, your laptop, via pull requests, exc..\nFor complicated analyses it may be appropriate to push both the main and develop branches to the organizational account. While main allows for staff to know where the analysis sat at it’s most recent reporting stage develop allows staff to track progress since the last report.\n\n\n\n\n\n\nConcerns about incomplete work can be addressed by keeping the repository private and explaining the state of the analysis in the commit messages and the README file.↩︎"
  }
]