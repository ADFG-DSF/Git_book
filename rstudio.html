<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.217">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>rstudio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="rstudio_files/libs/clipboard/clipboard.min.js"></script>
<script src="rstudio_files/libs/quarto-html/quarto.js"></script>
<script src="rstudio_files/libs/quarto-html/popper.min.js"></script>
<script src="rstudio_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="rstudio_files/libs/quarto-html/anchor.min.js"></script>
<link href="rstudio_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="rstudio_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="rstudio_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="rstudio_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="rstudio_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<section id="sec-rstudio" class="level2">
<h2 class="anchored" data-anchor-id="sec-rstudio">The RStudio Graphical User Interface</h2>
<p>Congratulations! If you are reading this you have done your homework and earned the right to confidently use a graphical user interface to simplify the most common Git tasks. Using a GUI can save a lot of keystrokes for most commands. The most accessible GUI is found in RStudio itself. A Git tab will show up in the Environment/History/Connections/Tutorial window (generally the upper left hand quadrant) provided your directory is a Git repository.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="RStudio_screen.PNG" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">The RStudio windows with the Git pane shown in the top right quadrant.</figcaption>
</figure>
</div>
<section id="git-init" class="level3">
<h3 class="anchored" data-anchor-id="git-init">git init</h3>
<p>If you are starting a brand new analysis, creating a git repository at the same time you create your R studio project is easy: <em>New Project&gt;New Directory&gt;New Project&gt;(provide name, location and check ‘create git repository’)</em>. This sequence runs git init in the background while the RStudio project is created.</p>
</section>
<section id="commands-accessible-through-the-git-tab" class="level3">
<h3 class="anchored" data-anchor-id="commands-accessible-through-the-git-tab">Commands accessible through the Git tab</h3>
<ul>
<li><p><code>git add</code> - add/Stage files by clicking the radio button next to each file in the RStudio Git pane.</p></li>
<li><p><code>git diff</code>- the <em>Diff</em> button will lead to another screen where the GUI allows users to <code>diff</code> and <code>commit</code> the repository.</p></li>
<li><p><code>git commit</code> - the <em>Commit</em> button will lead to another screen where the GUI allows users to <code>commit</code> and <code>diff</code> the repository.</p></li>
<li><p><code>git pull</code> - the <em>Pull</em> button allows the user to pull commits from the remote repository to the local repository.</p></li>
<li><p><code>git push</code> - the <em>Push</em> button allows the user to push commits from the local repository to the remote repository.</p></li>
<li><p><code>git log</code> - the <em>History</em> button will lead to another screen where the GUI allows users to <code>log</code> the repository.</p></li>
<li><p><code>git revert</code> - the <em>More</em> button will allow the user to <code>revert</code> a commit. It also allows the user to add files to the <code>.gitignore</code> file by clicking the radio button next to the files you wish to ignore.</p></li>
<li><p><code>git checkout -b</code> and <code>git remote</code> - the flowchart shaped button will allow you to create a new branch and add a remote to the repository.</p></li>
<li><p><code>git checkout &lt;new_branch&gt;</code> - the drop down list next to the word “main” will allow you to switch between branches.</p></li>
<li><p>Note the RStudio GUI is frequently slow to react to changes. The circular arrow refreshes the GUI. Often it will look like nothing is happening when you are clicking the radio buttons to add/stage files but clicking the refresh button will reveal the buttons were checked.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Rstudio_Git.PNG" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">The RStudio Git tab</figcaption>
</figure>
</div>
</section>
<section id="commands-accessible-through-the-diff-window" class="level3">
<h3 class="anchored" data-anchor-id="commands-accessible-through-the-diff-window">Commands accessible through the Diff window</h3>
<ul>
<li><p><code>git diff</code> - the <em>Changes</em> tab will show line by line changes associated with the files in the working directory relative to the most recent commit. Old lines are shown in red while new line are shown in green. In the example shown below x- and y-axis labels are added to the plot function.</p></li>
<li><p><code>git commit</code> - the <em>Changes</em> tab also includes a commit message window and a <em>Commit</em> button allowing the user to commit all of the staged changes. The commit title goes on the first line of the message window, followed by a blank line. The third line and onward contain the commit description.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Rstudio_commit.PNG" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">The Diff/Commit window</figcaption>
</figure>
</div>
</section>
<section id="commands-accessible-through-the-history-window" class="level3">
<h3 class="anchored" data-anchor-id="commands-accessible-through-the-history-window">Commands accessible through the History window</h3>
<ul>
<li><code>git log</code> - the <em>History</em> tab will show the list of prior commits and the line by line changes associated with each file included in each commit. In the example below manual Fibonacci sequence calculations were replaced with a for loop and a typo was corrected in the word “ratio”.</li>
<li><code>git checkout</code> - RStudio does not have a direct analog to using <code>git checkout</code> to recall a single file but the <em>View file @SHA-short</em> button will open a window which includes the code that was staged and committed during that SHA . It is possible to retrieve code from a previous commit in this manner using cut, paste and save point and click commands.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Rstudio_history.PNG" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">The History window</figcaption>
</figure>
</div>
</section>
<section id="commands-not-accessible-using-the-rstudio-gui" class="level3">
<h3 class="anchored" data-anchor-id="commands-not-accessible-using-the-rstudio-gui">Commands not accessible using the RStudio GUI</h3>
<p>To my knowledge there are certain commands that are not included in RStudio GUI.</p>
<ul>
<li><p><code>git merge</code> two branches. Since branching and merging is a big part of using git for model development this is a major omission. The GitKraken GUI handles merges nicely.</p></li>
<li><p>The Rstudio GUI display the Git log in a much cleaner format than the terminal with the big exception that the commit description is not visible. Since the commit description is the more informative part of the commit message this can be a substantial loss for some commits. A workaround would is to run the command <code>git show SHA-short -s –format=%B</code> where SHA-short is the short SHA tag for the commit description you wish to see. More powerful GUI’s (for example, GitKraken) can show the entire commit description.</p></li>
<li><p><code>git checkout</code> to recall a single file from a previous commit. Using the terminal is more deliberate and proably better if you want to recall all of a large file although the cut/paste workaround described above is generally sufficent if you just want t few lines of code from a previous commit.</p></li>
<li><p><code>git checkout</code> to recall a prior commit to your working directory.</p></li>
<li><p><code>git reset</code> to delete a local commit.</p></li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    if (id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        for (let i = 0; i < 2; i++) {
          container.appendChild(note.children[i].cloneNode(true));
        }
        return container.innerHTML
      } else {
        return note.innerHTML;
      }
    } else {
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      try { hash = new URL(url).hash; } catch {}
      const id = hash.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note !== null) {
        try {
          const html = processXRef(id, note);
          instance.setContent(html);
        } finally {
          instance.enable();
          instance.show();
        }
      } else {
        // See if we can fetch this
        fetch(url.split('#')[0])
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.getElementById(id);
          if (note !== null) {
            const html = processXRef(id, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>